/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { z } from 'zod'

export const appSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
  organization: z.lazy(() => organizationSchema).optional(),
  status: z.string().optional(),
})

export const appSecretSchema = z.object({
  digest: z.string().optional(),
  name: z.string().optional(),
  value: z.string().optional(),
})

export const appSecretsSchema = z.object({
  secrets: z.array(z.lazy(() => appSecretSchema)).optional(),
})

export const checkStatusSchema = z.object({
  name: z.string().optional(),
  output: z.string().optional(),
  status: z.string().optional(),
  updated_at: z.string().optional(),
})

export const createAppDeployTokenRequestSchema = z.object({
  expiry: z.string().optional(),
})

export const createAppRequestSchema = z.object({
  app_name: z.string().optional(),
  enable_subdomains: z.boolean().optional(),
  network: z.string().optional(),
  org_slug: z.string().optional(),
})

export const createAppResponseSchema = z.object({
  token: z.string().optional(),
})

export const createLeaseRequestSchema = z.object({
  description: z.string().optional(),
  ttl: z.number().int().describe('seconds lease will be valid').optional(),
})

export const createMachineRequestSchema = z.object({
  config: z
    .lazy(() => flyMachineConfigSchema)
    .describe('An object defining the Machine configuration')
    .optional(),
  lease_ttl: z.number().int().optional(),
  lsvd: z.boolean().optional(),
  min_secrets_version: z.number().int().optional(),
  name: z.string().describe('Unique name for this Machine. If omitted, one is generated for you').optional(),
  region: z
    .string()
    .describe('The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).')
    .optional(),
  skip_launch: z.boolean().optional(),
  skip_secrets: z.boolean().optional(),
  skip_service_registration: z.boolean().optional(),
})

/**
 * @description Optional parameters
 */
export const createOIDCTokenRequestSchema = z
  .object({
    aud: z.string().optional(),
    aws_principal_tags: z.boolean().optional(),
  })
  .describe('Optional parameters')

export const createVolumeRequestSchema = z.object({
  compute: z.lazy(() => flyMachineGuestSchema).optional(),
  compute_image: z.string().optional(),
  encrypted: z.boolean().optional(),
  fstype: z.string().optional(),
  name: z.string().optional(),
  region: z.string().optional(),
  require_unique_zone: z.boolean().optional(),
  size_gb: z.number().int().optional(),
  snapshot_id: z.string().describe('restore from snapshot').optional(),
  snapshot_retention: z.number().int().optional(),
  source_volume_id: z.string().describe('fork from remote volume').optional(),
  unique_zone_app_wide: z.boolean().optional(),
})

export const decryptSecretkeyRequestSchema = z.object({
  associated_data: z.array(z.number().int()).optional(),
  ciphertext: z.array(z.number().int()).optional(),
})

export const decryptSecretkeyResponseSchema = z.object({
  plaintext: z.array(z.number().int()).optional(),
})

export const encryptSecretkeyRequestSchema = z.object({
  associated_data: z.array(z.number().int()).optional(),
  plaintext: z.array(z.number().int()).optional(),
})

export const encryptSecretkeyResponseSchema = z.object({
  ciphertext: z.array(z.number().int()).optional(),
})

export const errorResponseSchema = z.object({
  details: z.object({}).describe('Deprecated').optional(),
  error: z.string().optional(),
  status: z.lazy(() => mainStatusCodeSchema).optional(),
})

export const extendVolumeRequestSchema = z.object({
  size_gb: z.number().int().optional(),
})

export const extendVolumeResponseSchema = z.object({
  needs_restart: z.boolean().optional(),
  volume: z.lazy(() => volumeSchema).optional(),
})

export const imageRefSchema = z.object({
  digest: z.string().optional(),
  labels: z.object({}).catchall(z.string()).optional(),
  registry: z.string().optional(),
  repository: z.string().optional(),
  tag: z.string().optional(),
})

export const leaseSchema = z.object({
  description: z.string().describe('Description or reason for the Lease.').optional(),
  expires_at: z.number().int().describe('ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid.').optional(),
  nonce: z.string().describe('Nonce is the unique ID autogenerated and associated with the Lease.').optional(),
  owner: z.string().describe('Owner is the user identifier which acquired the Lease.').optional(),
  version: z.string().describe('Machine version').optional(),
})

export const listAppSchema = z.object({
  id: z.string().optional(),
  machine_count: z.number().int().optional(),
  name: z.string().optional(),
  network: z.object({}).optional(),
})

export const listAppsResponseSchema = z.object({
  apps: z.array(z.lazy(() => listAppSchema)).optional(),
  total_apps: z.number().int().optional(),
})

export const listenSocketSchema = z.object({
  address: z.string().optional(),
  proto: z.string().optional(),
})

export const machineSchema = z.object({
  checks: z.array(z.lazy(() => checkStatusSchema)).optional(),
  config: z.lazy(() => flyMachineConfigSchema).optional(),
  created_at: z.string().optional(),
  events: z.array(z.lazy(() => machineEventSchema)).optional(),
  host_status: z.enum(['ok', 'unknown', 'unreachable']).optional(),
  id: z.string().optional(),
  image_ref: z.lazy(() => imageRefSchema).optional(),
  incomplete_config: z.lazy(() => flyMachineConfigSchema).optional(),
  instance_id: z.string().describe('InstanceID is unique for each version of the machine').optional(),
  name: z.string().optional(),
  nonce: z.string().describe('Nonce is only every returned on machine creation if a lease_duration was provided.').optional(),
  private_ip: z.string().describe('PrivateIP is the internal 6PN address of the machine.').optional(),
  region: z.string().optional(),
  state: z.string().optional(),
  updated_at: z.string().optional(),
})

export const machineEventSchema = z.object({
  id: z.string().optional(),
  request: z.object({}).optional(),
  source: z.string().optional(),
  status: z.string().optional(),
  timestamp: z.number().int().optional(),
  type: z.string().optional(),
})

export const machineExecRequestSchema = z.object({
  cmd: z.string().describe('Deprecated: use Command instead').optional(),
  command: z.array(z.string()).optional(),
  container: z.string().optional(),
  stdin: z.string().optional(),
  timeout: z.number().int().optional(),
})

export const machineVersionSchema = z.object({
  user_config: z.lazy(() => flyMachineConfigSchema).optional(),
  version: z.string().optional(),
})

export const organizationSchema = z.object({
  name: z.string().optional(),
  slug: z.string().optional(),
})

export const processStatSchema = z.object({
  command: z.string().optional(),
  cpu: z.number().int().optional(),
  directory: z.string().optional(),
  listen_sockets: z.array(z.lazy(() => listenSocketSchema)).optional(),
  pid: z.number().int().optional(),
  rss: z.number().int().optional(),
  rtime: z.number().int().optional(),
  stime: z.number().int().optional(),
})

export const secretKeySchema = z.object({
  name: z.string().optional(),
  public_key: z.array(z.number().int()).optional(),
  type: z.string().optional(),
})

export const secretKeysSchema = z.object({
  secret_keys: z.array(z.lazy(() => secretKeySchema)).optional(),
})

export const setAppSecretRequestSchema = z.object({
  value: z.string().optional(),
})

export const setAppSecretResponseSchema = z.object({
  digest: z.string().optional(),
  name: z.string().optional(),
  value: z.string().optional(),
  version: z.number().int().optional(),
})

export const setSecretkeyRequestSchema = z.object({
  type: z.string().optional(),
  value: z.array(z.number().int()).optional(),
})

export const setSecretkeyResponseSchema = z.object({
  name: z.string().optional(),
  public_key: z.array(z.number().int()).optional(),
  type: z.string().optional(),
  version: z.number().int().optional(),
})

export const signSecretkeyRequestSchema = z.object({
  plaintext: z.array(z.number().int()).optional(),
})

export const signSecretkeyResponseSchema = z.object({
  signature: z.array(z.number().int()).optional(),
})

export const signalRequestSchema = z.object({
  signal: z
    .enum(['SIGABRT', 'SIGALRM', 'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGKILL', 'SIGPIPE', 'SIGQUIT', 'SIGSEGV', 'SIGTERM', 'SIGTRAP', 'SIGUSR1'])
    .optional(),
})

export const stopRequestSchema = z.object({
  signal: z.string().optional(),
  timeout: z.lazy(() => flyDurationSchema).optional(),
})

export const updateMachineRequestSchema = z.object({
  config: z
    .lazy(() => flyMachineConfigSchema)
    .describe('An object defining the Machine configuration')
    .optional(),
  current_version: z.string().optional(),
  lease_ttl: z.number().int().optional(),
  lsvd: z.boolean().optional(),
  min_secrets_version: z.number().int().optional(),
  name: z.string().describe('Unique name for this Machine. If omitted, one is generated for you').optional(),
  region: z
    .string()
    .describe('The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).')
    .optional(),
  skip_launch: z.boolean().optional(),
  skip_secrets: z.boolean().optional(),
  skip_service_registration: z.boolean().optional(),
})

export const updateVolumeRequestSchema = z.object({
  auto_backup_enabled: z.boolean().optional(),
  snapshot_retention: z.number().int().optional(),
})

export const verifySecretkeyRequestSchema = z.object({
  plaintext: z.array(z.number().int()).optional(),
  signature: z.array(z.number().int()).optional(),
})

export const volumeSchema = z.object({
  attached_alloc_id: z.string().optional(),
  attached_machine_id: z.string().optional(),
  auto_backup_enabled: z.boolean().optional(),
  block_size: z.number().int().optional(),
  blocks: z.number().int().optional(),
  blocks_avail: z.number().int().optional(),
  blocks_free: z.number().int().optional(),
  bytes_total: z.number().int().optional(),
  bytes_used: z.number().int().optional(),
  created_at: z.string().optional(),
  encrypted: z.boolean().optional(),
  fstype: z.string().optional(),
  host_status: z.enum(['ok', 'unknown', 'unreachable']).optional(),
  id: z.string().optional(),
  name: z.string().optional(),
  region: z.string().optional(),
  size_gb: z.number().int().optional(),
  snapshot_retention: z.number().int().optional(),
  state: z.string().optional(),
  zone: z.string().optional(),
})

export const volumeSnapshotSchema = z.object({
  created_at: z.string().optional(),
  digest: z.string().optional(),
  id: z.string().optional(),
  retention_days: z.number().int().optional(),
  size: z.number().int().optional(),
  status: z.string().optional(),
})

export const flyContainerConfigSchema = z.object({
  cmd: z.array(z.string()).describe('CmdOverride is used to override the default command of the image.').optional(),
  depends_on: z
    .array(z.lazy(() => flyContainerDependencySchema))
    .describe(
      'DependsOn can be used to define dependencies between containers. The container will only be\nstarted after all of its dependent conditions have been satisfied.',
    )
    .optional(),
  entrypoint: z.array(z.string()).describe('EntrypointOverride is used to override the default entrypoint of the image.').optional(),
  env: z.object({}).catchall(z.string()).describe('ExtraEnv is used to add additional environment variables to the container.').optional(),
  env_from: z
    .array(z.lazy(() => flyEnvFromSchema).describe('EnvVar defines an environment variable to be populated from a machine field, env_var'))
    .describe('EnvFrom can be provided to set environment variables from machine fields.')
    .optional(),
  exec: z
    .array(z.string())
    .describe(
      'Image Config overrides - these fields are used to override the image configuration.\nIf not provided, the image configuration will be used.\nExecOverride is used to override the default command of the image.',
    )
    .optional(),
  files: z
    .array(z.lazy(() => flyFileSchema).describe('A file that will be written to the Machine. One of RawValue or SecretName must be set.'))
    .describe('Files are files that will be written to the container file system.')
    .optional(),
  healthchecks: z
    .array(z.lazy(() => flyContainerHealthcheckSchema))
    .describe('Healthchecks determine the health of your containers. Healthchecks can use HTTP, TCP or an Exec command.')
    .optional(),
  image: z.string().describe('Image is the docker image to run.').optional(),
  name: z.string().describe('Name is used to identify the container in the machine.').optional(),
  restart: z
    .lazy(() => flyMachineRestartSchema)
    .describe('Restart is used to define the restart policy for the container. NOTE: spot-price is not\nsupported for containers.')
    .optional(),
  secrets: z
    .array(z.lazy(() => flyMachineSecretSchema).describe('A Secret needing to be set in the environment of the Machine. env_var is required'))
    .describe(
      'Secrets can be provided at the process level to explicitly indicate which secrets should be\nused for the process. If not provided, the secrets provided at the machine level will be used.',
    )
    .optional(),
  stop: z
    .lazy(() => flyStopConfigSchema)
    .describe('Stop is used to define the signal and timeout for stopping the container.')
    .optional(),
  user: z.string().describe('UserOverride is used to override the default user of the image.').optional(),
})

export const flyContainerDependencySchema = z.object({
  condition: z.lazy(() => flyContainerDependencyConditionSchema).optional(),
  name: z.string().optional(),
})

export const flyContainerDependencyConditionSchema = z.enum(['exited_successfully', 'healthy', 'started'])

export const flyContainerHealthcheckSchema = z.object({
  exec: z.lazy(() => flyExecHealthcheckSchema).optional(),
  failure_threshold: z.number().int().describe('The number of times the check must fail before considering the container unhealthy.').optional(),
  grace_period: z.number().int().describe('The time in seconds to wait after a container starts before checking its health.').optional(),
  http: z.lazy(() => flyHTTPHealthcheckSchema).optional(),
  interval: z.number().int().describe('The time in seconds between executing the defined check.').optional(),
  kind: z
    .lazy(() => flyContainerHealthcheckKindSchema)
    .describe('Kind of healthcheck (readiness, liveness)')
    .optional(),
  name: z.string().describe('The name of the check. Must be unique within the container.').optional(),
  success_threshold: z.number().int().describe('The number of times the check must succeeed before considering the container healthy.').optional(),
  tcp: z.lazy(() => flyTCPHealthcheckSchema).optional(),
  timeout: z.number().int().describe('The time in seconds to wait for the check to complete.').optional(),
  unhealthy: z
    .lazy(() => flyUnhealthyPolicySchema)
    .describe('Unhealthy policy that determines what action to take if a container is deemed unhealthy')
    .optional(),
})

export const flyContainerHealthcheckKindSchema = z.enum(['readiness', 'liveness'])

export const flyContainerHealthcheckSchemeSchema = z.enum(['http', 'https'])

export const flyDNSConfigSchema = z.object({
  dns_forward_rules: z.array(z.lazy(() => flyDnsForwardRuleSchema)).optional(),
  hostname: z.string().optional(),
  hostname_fqdn: z.string().optional(),
  nameservers: z.array(z.string()).optional(),
  options: z.array(z.lazy(() => flyDnsOptionSchema)).optional(),
  searches: z.array(z.string()).optional(),
  skip_registration: z.boolean().optional(),
})

export const flyDurationSchema = z.object({
  'time.Duration': z.number().int().optional(),
})

/**
 * @description EnvVar defines an environment variable to be populated from a machine field, env_var
 */
export const flyEnvFromSchema = z
  .object({
    env_var: z
      .string()
      .describe(
        'EnvVar is required and is the name of the environment variable that will be set from the\nsecret. It must be a valid environment variable name.',
      )
      .optional(),
    field_ref: z
      .enum(['id', 'version', 'app_name', 'private_ip', 'region', 'image'])
      .describe('FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.')
      .optional(),
  })
  .describe('EnvVar defines an environment variable to be populated from a machine field, env_var')

export const flyExecHealthcheckSchema = z.object({
  command: z.array(z.string()).describe('The command to run to check the health of the container (e.g. ["cat", "/tmp/healthy"])').optional(),
})

/**
 * @description A file that will be written to the Machine. One of RawValue or SecretName must be set.
 */
export const flyFileSchema = z
  .object({
    guest_path: z
      .string()
      .describe('GuestPath is the path on the machine where the file will be written and must be an absolute path.\nFor example: /full/path/to/file.json')
      .optional(),
    image_config: z.string().describe('The name of an image to use the OCI image config as the file contents.').optional(),
    mode: z.number().int().describe('Mode bits used to set permissions on this file as accepted by chmod(2).').optional(),
    raw_value: z.string().describe('The base64 encoded string of the file contents.').optional(),
    secret_name: z.string().describe('The name of the secret that contains the base64 encoded file contents.').optional(),
  })
  .describe('A file that will be written to the Machine. One of RawValue or SecretName must be set.')

export const flyHTTPHealthcheckSchema = z.object({
  headers: z
    .array(
      z
        .lazy(() => flyMachineHTTPHeaderSchema)
        .describe(
          'For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.',
        ),
    )
    .describe('Additional headers to send with the request')
    .optional(),
  method: z.string().describe('The HTTP method to use to when making the request').optional(),
  path: z.string().describe('The path to send the request to').optional(),
  port: z.number().int().describe('The port to connect to, often the same as internal_port').optional(),
  scheme: z
    .lazy(() => flyContainerHealthcheckSchemeSchema)
    .describe('Whether to use http or https')
    .optional(),
  tls_server_name: z.string().describe('If the protocol is https, the hostname to use for TLS certificate validation').optional(),
  tls_skip_verify: z.boolean().describe('If the protocol is https, whether or not to verify the TLS certificate').optional(),
})

export const flyHTTPOptionsSchema = z.object({
  compress: z.boolean().optional(),
  h2_backend: z.boolean().optional(),
  headers_read_timeout: z.number().int().optional(),
  idle_timeout: z.number().int().optional(),
  response: z.lazy(() => flyHTTPResponseOptionsSchema).optional(),
})

export const flyHTTPResponseOptionsSchema = z.object({
  headers: z.object({}).catchall(z.object({})).optional(),
  pristine: z.boolean().optional(),
})

export const flyMachineCheckSchema = z.object({
  grace_period: z
    .lazy(() => flyDurationSchema)
    .describe('The time to wait after a VM starts before checking its health')
    .optional(),
  headers: z
    .array(
      z
        .lazy(() => flyMachineHTTPHeaderSchema)
        .describe(
          'For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.',
        ),
    )
    .optional(),
  interval: z
    .lazy(() => flyDurationSchema)
    .describe('The time between connectivity checks')
    .optional(),
  kind: z.enum(['informational', 'readiness']).describe('Kind of the check (informational, readiness)').optional(),
  method: z.string().describe('For http checks, the HTTP method to use to when making the request').optional(),
  path: z.string().describe('For http checks, the path to send the request to').optional(),
  port: z.number().int().describe('The port to connect to, often the same as internal_port').optional(),
  protocol: z.string().describe('For http checks, whether to use http or https').optional(),
  timeout: z
    .lazy(() => flyDurationSchema)
    .describe('The maximum time a connection can take before being reported as failing its health check')
    .optional(),
  tls_server_name: z.string().describe('If the protocol is https, the hostname to use for TLS certificate validation').optional(),
  tls_skip_verify: z.boolean().describe('For http checks with https protocol, whether or not to verify the TLS certificate').optional(),
  type: z.string().describe('tcp or http').optional(),
})

export const flyMachineConfigSchema = z.object({
  auto_destroy: z.boolean().describe('Optional boolean telling the Machine to destroy itself once it’s complete (default false)').optional(),
  checks: z
    .object({})
    .catchall(z.lazy(() => flyMachineCheckSchema))
    .describe('An optional object that defines one or more named top-level checks. The key for each check is the check name.')
    .optional(),
  containers: z
    .array(z.lazy(() => flyContainerConfigSchema))
    .describe('Containers are a list of containers that will run in the machine. Currently restricted to\nonly specific organizations.')
    .optional(),
  disable_machine_autostart: z.boolean().describe('Deprecated: use Service.Autostart instead').optional(),
  dns: z.lazy(() => flyDNSConfigSchema).optional(),
  env: z.object({}).catchall(z.string()).describe('An object filled with key/value pairs to be set as environment variables').optional(),
  files: z.array(z.lazy(() => flyFileSchema).describe('A file that will be written to the Machine. One of RawValue or SecretName must be set.')).optional(),
  guest: z.lazy(() => flyMachineGuestSchema).optional(),
  image: z.string().describe('The docker image to run').optional(),
  init: z.lazy(() => flyMachineInitSchema).optional(),
  metadata: z.object({}).catchall(z.string()).optional(),
  metrics: z.lazy(() => flyMachineMetricsSchema).optional(),
  processes: z.array(z.lazy(() => flyMachineProcessSchema)).optional(),
  restart: z
    .lazy(() => flyMachineRestartSchema)
    .describe(
      'The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.',
    )
    .optional(),
  schedule: z.string().optional(),
  services: z.array(z.lazy(() => flyMachineServiceSchema)).optional(),
  size: z.string().describe('Deprecated: use Guest instead').optional(),
  standbys: z
    .array(z.string())
    .describe('Standbys enable a machine to be a standby for another. In the event of a hardware failure,\nthe standby machine will be started.')
    .optional(),
  statics: z.array(z.lazy(() => flyStaticSchema)).optional(),
  stop_config: z.lazy(() => flyStopConfigSchema).optional(),
})

export const flyMachineGuestSchema = z.object({
  cpu_kind: z.string().optional(),
  cpus: z.number().int().optional(),
  gpu_kind: z.string().optional(),
  gpus: z.number().int().optional(),
  host_dedication_id: z.string().optional(),
  kernel_args: z.array(z.string()).optional(),
  memory_mb: z.number().int().optional(),
})

/**
 * @description For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.
 */
export const flyMachineHTTPHeaderSchema = z
  .object({
    name: z.string().describe('The header name').optional(),
    values: z.array(z.string()).describe('The header value').optional(),
  })
  .describe(
    'For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.',
  )

export const flyMachineInitSchema = z.object({
  cmd: z.array(z.string()).optional(),
  entrypoint: z.array(z.string()).optional(),
  exec: z.array(z.string()).optional(),
  kernel_args: z.array(z.string()).optional(),
  swap_size_mb: z.number().int().optional(),
  tty: z.boolean().optional(),
})

export const flyMachineMetricsSchema = z.object({
  https: z.boolean().optional(),
  path: z.string().optional(),
  port: z.number().int().optional(),
})

export const flyMachinePortSchema = z.object({
  end_port: z.number().int().optional(),
  force_https: z.boolean().optional(),
  handlers: z.array(z.string()).optional(),
  http_options: z.lazy(() => flyHTTPOptionsSchema).optional(),
  port: z.number().int().optional(),
  proxy_proto_options: z.lazy(() => flyProxyProtoOptionsSchema).optional(),
  start_port: z.number().int().optional(),
  tls_options: z.lazy(() => flyTLSOptionsSchema).optional(),
})

export const flyMachineProcessSchema = z.object({
  cmd: z.array(z.string()).optional(),
  entrypoint: z.array(z.string()).optional(),
  env: z.object({}).catchall(z.string()).optional(),
  env_from: z
    .array(z.lazy(() => flyEnvFromSchema).describe('EnvVar defines an environment variable to be populated from a machine field, env_var'))
    .describe('EnvFrom can be provided to set environment variables from machine fields.')
    .optional(),
  exec: z.array(z.string()).optional(),
  ignore_app_secrets: z
    .boolean()
    .describe(
      'IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to\nand only use the secrets provided at the process level. The default/legacy behavior is to use\nthe secrets provided at the App level.',
    )
    .optional(),
  secrets: z
    .array(z.lazy(() => flyMachineSecretSchema).describe('A Secret needing to be set in the environment of the Machine. env_var is required'))
    .describe(
      'Secrets can be provided at the process level to explicitly indicate which secrets should be\nused for the process. If not provided, the secrets provided at the machine level will be used.',
    )
    .optional(),
  user: z.string().optional(),
})

/**
 * @description The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.
 */
export const flyMachineRestartSchema = z
  .object({
    gpu_bid_price: z.number().describe('GPU bid price for spot Machines.').optional(),
    max_retries: z
      .number()
      .int()
      .describe('When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop.')
      .optional(),
    policy: z
      .enum(['no', 'always', 'on-failure', 'spot-price'])
      .describe(
        '* no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.\n* always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.\n* on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.\n* spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.',
      )
      .optional(),
  })
  .describe(
    'The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.',
  )

/**
 * @description A Secret needing to be set in the environment of the Machine. env_var is required
 */
export const flyMachineSecretSchema = z
  .object({
    env_var: z
      .string()
      .describe(
        'EnvVar is required and is the name of the environment variable that will be set from the\nsecret. It must be a valid environment variable name.',
      )
      .optional(),
    name: z
      .string()
      .describe('Name is optional and when provided is used to reference a secret name where the EnvVar is\ndifferent from what was set as the secret name.')
      .optional(),
  })
  .describe('A Secret needing to be set in the environment of the Machine. env_var is required')

export const flyMachineServiceSchema = z.object({
  autostart: z.boolean().optional(),
  autostop: z
    .enum(['off', 'stop', 'suspend'])
    .describe(
      'Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.\n* "off" or false - Do not autostop the Machine.\n* "stop" or true - Automatically stop the Machine.\n* "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.',
    )
    .optional(),
  checks: z
    .array(z.lazy(() => flyMachineServiceCheckSchema))
    .describe('An optional list of service checks')
    .optional(),
  concurrency: z.lazy(() => flyMachineServiceConcurrencySchema).optional(),
  force_instance_description: z.string().optional(),
  force_instance_key: z.string().optional(),
  internal_port: z.number().int().optional(),
  min_machines_running: z.number().int().optional(),
  ports: z.array(z.lazy(() => flyMachinePortSchema)).optional(),
  protocol: z.string().optional(),
})

export const flyMachineServiceCheckSchema = z.object({
  grace_period: z
    .lazy(() => flyDurationSchema)
    .describe('The time to wait after a VM starts before checking its health')
    .optional(),
  headers: z
    .array(
      z
        .lazy(() => flyMachineHTTPHeaderSchema)
        .describe(
          'For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.',
        ),
    )
    .optional(),
  interval: z
    .lazy(() => flyDurationSchema)
    .describe('The time between connectivity checks')
    .optional(),
  method: z.string().describe('For http checks, the HTTP method to use to when making the request').optional(),
  path: z.string().describe('For http checks, the path to send the request to').optional(),
  port: z.number().int().describe('The port to connect to, often the same as internal_port').optional(),
  protocol: z.string().describe('For http checks, whether to use http or https').optional(),
  timeout: z
    .lazy(() => flyDurationSchema)
    .describe('The maximum time a connection can take before being reported as failing its health check')
    .optional(),
  tls_server_name: z.string().describe('If the protocol is https, the hostname to use for TLS certificate validation').optional(),
  tls_skip_verify: z.boolean().describe('For http checks with https protocol, whether or not to verify the TLS certificate').optional(),
  type: z.string().describe('tcp or http').optional(),
})

export const flyMachineServiceConcurrencySchema = z.object({
  hard_limit: z.number().int().optional(),
  soft_limit: z.number().int().optional(),
  type: z.string().optional(),
})

export const flyProxyProtoOptionsSchema = z.object({
  version: z.string().optional(),
})

export const flyStaticSchema = z.object({
  guest_path: z.string(),
  index_document: z.string().optional(),
  tigris_bucket: z.string().optional(),
  url_prefix: z.string(),
})

export const flyStopConfigSchema = z.object({
  signal: z.string().optional(),
  timeout: z.lazy(() => flyDurationSchema).optional(),
})

export const flyTCPHealthcheckSchema = z.object({
  port: z.number().int().describe('The port to connect to, often the same as internal_port').optional(),
})

export const flyTLSOptionsSchema = z.object({
  alpn: z.array(z.string()).optional(),
  default_self_signed: z.boolean().optional(),
  versions: z.array(z.string()).optional(),
})

export const flyUnhealthyPolicySchema = z.enum(['stop'])

export const flyDnsForwardRuleSchema = z.object({
  addr: z.string().optional(),
  basename: z.string().optional(),
})

export const flyDnsOptionSchema = z.object({
  name: z.string().optional(),
  value: z.string().optional(),
})

export const flydv1ExecResponseSchema = z.object({
  exit_code: z.number().int().optional(),
  exit_signal: z.number().int().optional(),
  stderr: z.string().optional(),
  stdout: z.string().optional(),
})

export const mainGetPlacementsRequestSchema = z.object({
  compute: z
    .lazy(() => flyMachineGuestSchema)
    .describe('Resource requirements for the Machine to simulate. Defaults to a performance-1x machine')
    .optional(),
  count: z
    .number()
    .int()
    .describe('Number of machines to simulate placement.\nDefaults to 0, which returns the org-specific limit for each region.')
    .optional(),
  org_slug: z.string(),
  region: z
    .string()
    .describe(
      'Region expression for placement as a comma-delimited set of regions or aliases.\nDefaults to "[region],any", to prefer the API endpoint\'s local region with any other region as fallback.',
    )
    .optional(),
  volume_name: z.string().optional(),
  volume_size_bytes: z.number().int().optional(),
  weights: z
    .lazy(() => placementWeightsSchema)
    .describe('Optional weights to override default placement preferences.')
    .optional(),
})

export const mainGetPlacementsResponseSchema = z.object({
  regions: z.array(z.lazy(() => placementRegionPlacementSchema)).optional(),
})

export const mainRegionResponseSchema = z.object({
  regions: z.array(z.lazy(() => readsGetCapacityPerRegionRowSchema)).optional(),
})

export const mainStatusCodeSchema = z.enum(['unknown', 'insufficient_capacity'])

export const placementRegionPlacementSchema = z.object({
  concurrency: z
    .number()
    .int()
    .describe('Hint on the number of machines in this region can be created concurrently.\nEqual to the number of unique hosts selected for placement.')
    .optional(),
  count: z.number().int().optional(),
  region: z.string().optional(),
})

export const placementWeightsSchema = z.object({}).catchall(z.number().int())

export const readsGetCapacityPerRegionRowSchema = z.object({
  capacity: z.number().int().optional(),
  code: z.string().optional(),
  gateway_available: z.boolean().optional(),
  geo_region: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  name: z.string().optional(),
  requires_paid_plan: z.boolean().optional(),
})

export const appsListQueryParamsSchema = z.object({
  org_slug: z.string().describe("The org slug, or 'personal', to filter apps"),
})

/**
 * @description OK
 */
export const appsList200Schema = z.lazy(() => listAppsResponseSchema)

export const appsListQueryResponseSchema = z.lazy(() => appsList200Schema)

/**
 * @description Created
 */
export const appsCreate201Schema = z.any()

/**
 * @description Bad Request
 */
export const appsCreate400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description App body
 */
export const appsCreateMutationRequestSchema = z.lazy(() => createAppRequestSchema)

export const appsCreateMutationResponseSchema = z.lazy(() => appsCreate201Schema)

export const appsShowPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

/**
 * @description OK
 */
export const appsShow200Schema = z.lazy(() => appSchema)

export const appsShowQueryResponseSchema = z.lazy(() => appsShow200Schema)

export const appsDeletePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

/**
 * @description Accepted
 */
export const appsDelete202Schema = z.any()

export const appsDeleteMutationResponseSchema = z.lazy(() => appsDelete202Schema)

export const appCreateDeployTokenPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

/**
 * @description OK
 */
export const appCreateDeployToken200Schema = z.lazy(() => createAppResponseSchema)

/**
 * @description Request body
 */
export const appCreateDeployTokenMutationRequestSchema = z.lazy(() => createAppDeployTokenRequestSchema)

export const appCreateDeployTokenMutationResponseSchema = z.lazy(() => appCreateDeployToken200Schema)

export const machinesListPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

export const machinesListQueryParamsSchema = z
  .object({
    include_deleted: z.boolean().describe('Include deleted machines').optional(),
    region: z.string().describe('Region filter').optional(),
    state: z.string().describe('comma separated list of states to filter (created, started, stopped, suspended)').optional(),
    summary: z.boolean().describe('Only return summary info about machines (omit config, checks, events, host_status, nonce, etc.)').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesList200Schema = z.array(z.lazy(() => machineSchema))

export const machinesListQueryResponseSchema = z.lazy(() => machinesList200Schema)

export const machinesCreatePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

/**
 * @description OK
 */
export const machinesCreate200Schema = z.lazy(() => machineSchema)

/**
 * @description Create machine request
 */
export const machinesCreateMutationRequestSchema = z.lazy(() => createMachineRequestSchema)

export const machinesCreateMutationResponseSchema = z.lazy(() => machinesCreate200Schema)

export const machinesShowPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesShow200Schema = z.lazy(() => machineSchema)

export const machinesShowQueryResponseSchema = z.lazy(() => machinesShow200Schema)

export const machinesUpdatePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesUpdate200Schema = z.lazy(() => machineSchema)

/**
 * @description Bad Request
 */
export const machinesUpdate400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Request body
 */
export const machinesUpdateMutationRequestSchema = z.lazy(() => updateMachineRequestSchema)

export const machinesUpdateMutationResponseSchema = z.lazy(() => machinesUpdate200Schema)

export const machinesDeletePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesDeleteQueryParamsSchema = z
  .object({
    force: z.boolean().describe("Force kill the machine if it's running").optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesDelete200Schema = z.any()

export const machinesDeleteMutationResponseSchema = z.lazy(() => machinesDelete200Schema)

export const machinesCordonPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesCordon200Schema = z.any()

export const machinesCordonMutationResponseSchema = z.lazy(() => machinesCordon200Schema)

export const machinesListEventsPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesListEvents200Schema = z.array(z.lazy(() => machineEventSchema))

export const machinesListEventsQueryResponseSchema = z.lazy(() => machinesListEvents200Schema)

export const machinesExecPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description stdout, stderr, exit code, and exit signal are returned
 */
export const machinesExec200Schema = z.lazy(() => flydv1ExecResponseSchema)

/**
 * @description Bad Request
 */
export const machinesExec400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Request body
 */
export const machinesExecMutationRequestSchema = z.lazy(() => machineExecRequestSchema)

export const machinesExecMutationResponseSchema = z.lazy(() => machinesExec200Schema)

export const machinesShowLeasePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesShowLease200Schema = z.lazy(() => leaseSchema)

export const machinesShowLeaseQueryResponseSchema = z.lazy(() => machinesShowLease200Schema)

export const machinesCreateLeasePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesCreateLeaseHeaderParamsSchema = z
  .object({
    'fly-machine-lease-nonce': z.string().describe('Existing lease nonce to refresh by ttl, empty or non-existent to create a new lease').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesCreateLease200Schema = z.lazy(() => leaseSchema)

/**
 * @description Request body
 */
export const machinesCreateLeaseMutationRequestSchema = z.lazy(() => createLeaseRequestSchema)

export const machinesCreateLeaseMutationResponseSchema = z.lazy(() => machinesCreateLease200Schema)

export const machinesReleaseLeasePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesReleaseLeaseHeaderParamsSchema = z.object({
  'fly-machine-lease-nonce': z.string().describe('Existing lease nonce'),
})

/**
 * @description OK
 */
export const machinesReleaseLease200Schema = z.any()

export const machinesReleaseLeaseMutationResponseSchema = z.lazy(() => machinesReleaseLease200Schema)

export const machinesShowMetadataPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesShowMetadata200Schema = z.object({}).catchall(z.string())

export const machinesShowMetadataQueryResponseSchema = z.lazy(() => machinesShowMetadata200Schema)

export const machinesUpdateMetadataPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
  key: z.string().describe('Metadata Key'),
})

/**
 * @description No Content
 */
export const machinesUpdateMetadata204Schema = z.any()

/**
 * @description Bad Request
 */
export const machinesUpdateMetadata400Schema = z.lazy(() => errorResponseSchema)

export const machinesUpdateMetadataMutationResponseSchema = z.lazy(() => machinesUpdateMetadata204Schema)

export const machinesDeleteMetadataPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
  key: z.string().describe('Metadata Key'),
})

/**
 * @description No Content
 */
export const machinesDeleteMetadata204Schema = z.any()

export const machinesDeleteMetadataMutationResponseSchema = z.lazy(() => machinesDeleteMetadata204Schema)

export const machinesListProcessesPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesListProcessesQueryParamsSchema = z
  .object({
    sort_by: z.string().describe('Sort by').optional(),
    order: z.string().describe('Order').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesListProcesses200Schema = z.array(z.lazy(() => processStatSchema))

/**
 * @description Bad Request
 */
export const machinesListProcesses400Schema = z.lazy(() => errorResponseSchema)

export const machinesListProcessesQueryResponseSchema = z.lazy(() => machinesListProcesses200Schema)

export const machinesRestartPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesRestartQueryParamsSchema = z
  .object({
    timeout: z.string().describe('Restart timeout as a Go duration string or number of seconds').optional(),
    signal: z.string().describe('Unix signal name').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesRestart200Schema = z.any()

/**
 * @description Bad Request
 */
export const machinesRestart400Schema = z.lazy(() => errorResponseSchema)

export const machinesRestartMutationResponseSchema = z.lazy(() => machinesRestart200Schema)

export const machinesSignalPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesSignal200Schema = z.any()

/**
 * @description Bad Request
 */
export const machinesSignal400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Request body
 */
export const machinesSignalMutationRequestSchema = z.lazy(() => signalRequestSchema)

export const machinesSignalMutationResponseSchema = z.lazy(() => machinesSignal200Schema)

export const machinesStartPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesStart200Schema = z.any()

export const machinesStartMutationResponseSchema = z.lazy(() => machinesStart200Schema)

export const machinesStopPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesStop200Schema = z.any()

/**
 * @description Bad Request
 */
export const machinesStop400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Optional request body
 */
export const machinesStopMutationRequestSchema = z.lazy(() => stopRequestSchema)

export const machinesStopMutationResponseSchema = z.lazy(() => machinesStop200Schema)

export const machinesSuspendPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesSuspend200Schema = z.any()

export const machinesSuspendMutationResponseSchema = z.lazy(() => machinesSuspend200Schema)

export const machinesUncordonPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesUncordon200Schema = z.any()

export const machinesUncordonMutationResponseSchema = z.lazy(() => machinesUncordon200Schema)

export const machinesListVersionsPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

/**
 * @description OK
 */
export const machinesListVersions200Schema = z.array(z.lazy(() => machineVersionSchema))

export const machinesListVersionsQueryResponseSchema = z.lazy(() => machinesListVersions200Schema)

export const machinesWaitPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  machine_id: z.string().describe('Machine ID'),
})

export const machinesWaitQueryParamsSchema = z
  .object({
    instance_id: z.string().describe('26-character Machine version ID').optional(),
    timeout: z.coerce.number().int().describe('wait timeout. default 60s').optional(),
    state: z.enum(['started', 'stopped', 'suspended', 'destroyed']).describe('desired state').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const machinesWait200Schema = z.any()

/**
 * @description Bad Request
 */
export const machinesWait400Schema = z.lazy(() => errorResponseSchema)

export const machinesWaitQueryResponseSchema = z.lazy(() => machinesWait200Schema)

export const secretkeysListPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

export const secretkeysListQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
    types: z.string().describe('Comma-seperated list of secret keys to list').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretkeysList200Schema = z.lazy(() => secretKeysSchema)

export const secretkeysListQueryResponseSchema = z.lazy(() => secretkeysList200Schema)

export const secretkeyGetPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

export const secretkeyGetQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretkeyGet200Schema = z.lazy(() => secretKeySchema)

export const secretkeyGetQueryResponseSchema = z.lazy(() => secretkeyGet200Schema)

export const secretkeySetPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

/**
 * @description Created
 */
export const secretkeySet201Schema = z.lazy(() => setSecretkeyResponseSchema)

/**
 * @description Bad Request
 */
export const secretkeySet400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Create secret key request
 */
export const secretkeySetMutationRequestSchema = z.lazy(() => setSecretkeyRequestSchema)

export const secretkeySetMutationResponseSchema = z.lazy(() => secretkeySet201Schema)

export const secretkeyDeletePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

/**
 * @description No Content
 */
export const secretkeyDelete204Schema = z.any()

export const secretkeyDeleteMutationResponseSchema = z.lazy(() => secretkeyDelete204Schema)

export const secretkeyDecryptPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

export const secretkeyDecryptQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretkeyDecrypt200Schema = z.lazy(() => decryptSecretkeyResponseSchema)

/**
 * @description Bad Request
 */
export const secretkeyDecrypt400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Decrypt with secret key request
 */
export const secretkeyDecryptMutationRequestSchema = z.lazy(() => decryptSecretkeyRequestSchema)

export const secretkeyDecryptMutationResponseSchema = z.lazy(() => secretkeyDecrypt200Schema)

export const secretkeyEncryptPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

export const secretkeyEncryptQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretkeyEncrypt200Schema = z.lazy(() => encryptSecretkeyResponseSchema)

/**
 * @description Bad Request
 */
export const secretkeyEncrypt400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Encrypt with secret key request
 */
export const secretkeyEncryptMutationRequestSchema = z.lazy(() => encryptSecretkeyRequestSchema)

export const secretkeyEncryptMutationResponseSchema = z.lazy(() => secretkeyEncrypt200Schema)

export const secretkeyGeneratePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

/**
 * @description Created
 */
export const secretkeyGenerate201Schema = z.lazy(() => setSecretkeyResponseSchema)

/**
 * @description Bad Request
 */
export const secretkeyGenerate400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description generate secret key request
 */
export const secretkeyGenerateMutationRequestSchema = z.lazy(() => setSecretkeyRequestSchema)

export const secretkeyGenerateMutationResponseSchema = z.lazy(() => secretkeyGenerate201Schema)

export const secretkeySignPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

export const secretkeySignQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretkeySign200Schema = z.lazy(() => signSecretkeyResponseSchema)

/**
 * @description Bad Request
 */
export const secretkeySign400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Sign with secret key request
 */
export const secretkeySignMutationRequestSchema = z.lazy(() => signSecretkeyRequestSchema)

export const secretkeySignMutationResponseSchema = z.lazy(() => secretkeySign200Schema)

export const secretkeyVerifyPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('Secret key name'),
})

export const secretkeyVerifyQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
  })
  .optional()

/**
 * @description No Content
 */
export const secretkeyVerify204Schema = z.any()

/**
 * @description Bad Request
 */
export const secretkeyVerify400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Verify with secret key request
 */
export const secretkeyVerifyMutationRequestSchema = z.lazy(() => verifySecretkeyRequestSchema)

export const secretkeyVerifyMutationResponseSchema = z.lazy(() => secretkeyVerify204Schema)

export const secretsListPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

export const secretsListQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
    show_secrets: z.boolean().describe('Show the secret values.').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretsList200Schema = z.lazy(() => appSecretsSchema)

export const secretsListQueryResponseSchema = z.lazy(() => secretsList200Schema)

export const secretGetPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('App secret name'),
})

export const secretGetQueryParamsSchema = z
  .object({
    min_version: z.string().describe('Minimum secrets version to return. Returned when setting a new secret').optional(),
    show_secrets: z.boolean().describe('Show the secret value.').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const secretGet200Schema = z.lazy(() => appSecretSchema)

export const secretGetQueryResponseSchema = z.lazy(() => secretGet200Schema)

export const secretCreatePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('App secret name'),
})

/**
 * @description Created
 */
export const secretCreate201Schema = z.lazy(() => setAppSecretResponseSchema)

/**
 * @description Bad Request
 */
export const secretCreate400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Create app secret request
 */
export const secretCreateMutationRequestSchema = z.lazy(() => setAppSecretRequestSchema)

export const secretCreateMutationResponseSchema = z.lazy(() => secretCreate201Schema)

export const secretDeletePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  secret_name: z.string().describe('App secret name'),
})

/**
 * @description No Content
 */
export const secretDelete204Schema = z.any()

export const secretDeleteMutationResponseSchema = z.lazy(() => secretDelete204Schema)

export const volumesListPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

export const volumesListQueryParamsSchema = z
  .object({
    summary: z.boolean().describe('Only return summary info about volumes (omit blocks, block size, etc)').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const volumesList200Schema = z.array(z.lazy(() => volumeSchema))

export const volumesListQueryResponseSchema = z.lazy(() => volumesList200Schema)

export const volumesCreatePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
})

/**
 * @description OK
 */
export const volumesCreate200Schema = z.lazy(() => volumeSchema)

/**
 * @description Request body
 */
export const volumesCreateMutationRequestSchema = z.lazy(() => createVolumeRequestSchema)

export const volumesCreateMutationResponseSchema = z.lazy(() => volumesCreate200Schema)

export const volumesGetByIdPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const volumesGetById200Schema = z.lazy(() => volumeSchema)

export const volumesGetByIdQueryResponseSchema = z.lazy(() => volumesGetById200Schema)

export const volumesUpdatePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const volumesUpdate200Schema = z.lazy(() => volumeSchema)

/**
 * @description Bad Request
 */
export const volumesUpdate400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Request body
 */
export const volumesUpdateMutationRequestSchema = z.lazy(() => updateVolumeRequestSchema)

export const volumesUpdateMutationResponseSchema = z.lazy(() => volumesUpdate200Schema)

export const volumeDeletePathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const volumeDelete200Schema = z.lazy(() => volumeSchema)

export const volumeDeleteMutationResponseSchema = z.lazy(() => volumeDelete200Schema)

export const volumesExtendPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const volumesExtend200Schema = z.lazy(() => extendVolumeResponseSchema)

/**
 * @description Request body
 */
export const volumesExtendMutationRequestSchema = z.lazy(() => extendVolumeRequestSchema)

export const volumesExtendMutationResponseSchema = z.lazy(() => volumesExtend200Schema)

export const volumesListSnapshotsPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const volumesListSnapshots200Schema = z.array(z.lazy(() => volumeSnapshotSchema))

export const volumesListSnapshotsQueryResponseSchema = z.lazy(() => volumesListSnapshots200Schema)

export const createVolumeSnapshotPathParamsSchema = z.object({
  app_name: z.string().describe('Fly App Name'),
  volume_id: z.string().describe('Volume ID'),
})

/**
 * @description OK
 */
export const createVolumeSnapshot200Schema = z.any()

export const createVolumeSnapshotMutationResponseSchema = z.lazy(() => createVolumeSnapshot200Schema)

/**
 * @description OK
 */
export const platformPlacementsPost200Schema = z.lazy(() => mainGetPlacementsResponseSchema)

/**
 * @description Get placements request
 */
export const platformPlacementsPostMutationRequestSchema = z.lazy(() => mainGetPlacementsRequestSchema)

export const platformPlacementsPostMutationResponseSchema = z.lazy(() => platformPlacementsPost200Schema)

export const platformRegionsGetQueryParamsSchema = z
  .object({
    size: z.string().describe('guest machine size preset. default performance-1x').optional(),
    cpu_kind: z.string().describe('guest CPU kind').optional(),
    memory_mb: z.coerce.number().int().describe('guest memory in megabytes').optional(),
    cpus: z.coerce.number().int().describe('guest CPU count').optional(),
    gpus: z.coerce.number().int().describe('guest GPU count').optional(),
    gpu_kind: z.string().describe('guest GPU kind').optional(),
  })
  .optional()

/**
 * @description OK
 */
export const platformRegionsGet200Schema = z.lazy(() => mainRegionResponseSchema)

export const platformRegionsGetQueryResponseSchema = z.lazy(() => platformRegionsGet200Schema)

/**
 * @description KMS token
 */
export const tokensRequestKms200Schema = z.string()

export const tokensRequestKmsMutationResponseSchema = z.lazy(() => tokensRequestKms200Schema)

/**
 * @description OIDC token
 */
export const tokensRequestOIDC200Schema = z.string()

/**
 * @description Bad Request
 */
export const tokensRequestOIDC400Schema = z.lazy(() => errorResponseSchema)

/**
 * @description Optional request body
 */
export const tokensRequestOIDCMutationRequestSchema = z.lazy(() => createOIDCTokenRequestSchema).describe('Optional parameters')

export const tokensRequestOIDCMutationResponseSchema = z.lazy(() => tokensRequestOIDC200Schema)
