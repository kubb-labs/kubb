/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import type { RequestConfig, ResponseErrorConfig } from '@kubb/plugin-client/clients/axios'
import fetch from '@kubb/plugin-client/clients/axios'
import type {
  QueryClient,
  QueryKey,
  QueryObserverOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query'
import { mutationOptions, queryOptions, useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query'
import type {
  AddPetRequestData9,
  AddPetResponseData9,
  AddPetStatus4059,
  CreateUserRequestData9,
  CreateUserResponseData9,
  CreateUsersWithListInputRequestData9,
  CreateUsersWithListInputResponseData9,
  DeleteOrderPathParams9,
  DeleteOrderResponseData9,
  DeleteOrderStatus4009,
  DeleteOrderStatus4049,
  DeletePetHeaderParams9,
  DeletePetPathParams9,
  DeletePetResponseData9,
  DeletePetStatus4009,
  DeleteUserPathParams9,
  DeleteUserResponseData9,
  DeleteUserStatus4009,
  DeleteUserStatus4049,
  FindPetsByStatusQueryParams,
  FindPetsByStatusQueryParams3,
  FindPetsByStatusResponseData,
  FindPetsByStatusResponseData3,
  FindPetsByStatusStatus400,
  FindPetsByStatusStatus4003,
  FindPetsByTagsQueryParams,
  FindPetsByTagsQueryParams3,
  FindPetsByTagsResponseData,
  FindPetsByTagsResponseData3,
  FindPetsByTagsStatus400,
  FindPetsByTagsStatus4003,
  GetInventoryResponseData,
  GetInventoryResponseData3,
  GetOrderByIdPathParams,
  GetOrderByIdPathParams3,
  GetOrderByIdResponseData,
  GetOrderByIdResponseData3,
  GetOrderByIdStatus400,
  GetOrderByIdStatus404,
  GetOrderByIdStatus4003,
  GetOrderByIdStatus4043,
  GetPetByIdPathParams,
  GetPetByIdPathParams3,
  GetPetByIdResponseData,
  GetPetByIdResponseData3,
  GetPetByIdStatus400,
  GetPetByIdStatus404,
  GetPetByIdStatus4003,
  GetPetByIdStatus4043,
  GetUserByNamePathParams,
  GetUserByNamePathParams3,
  GetUserByNameResponseData,
  GetUserByNameResponseData3,
  GetUserByNameStatus400,
  GetUserByNameStatus404,
  GetUserByNameStatus4003,
  GetUserByNameStatus4043,
  LoginUserQueryParams,
  LoginUserQueryParams3,
  LoginUserResponseData,
  LoginUserResponseData3,
  LoginUserStatus400,
  LoginUserStatus4003,
  LogoutUserResponseData,
  LogoutUserResponseData3,
  PlaceOrderPatchRequestData9,
  PlaceOrderPatchResponseData9,
  PlaceOrderPatchStatus4059,
  PlaceOrderRequestData9,
  PlaceOrderResponseData9,
  PlaceOrderStatus4059,
  UpdatePetRequestData9,
  UpdatePetResponseData9,
  UpdatePetStatus4009,
  UpdatePetStatus4049,
  UpdatePetStatus4059,
  UpdatePetWithFormPathParams9,
  UpdatePetWithFormQueryParams9,
  UpdatePetWithFormResponseData9,
  UpdatePetWithFormStatus4059,
  UpdateUserPathParams9,
  UpdateUserRequestData9,
  UpdateUserResponseData9,
  UploadFilePathParams9,
  UploadFileQueryParams9,
  UploadFileRequestData9,
  UploadFileResponseData9,
} from './models'

export const findPetsByStatusQueryKey = (params?: FindPetsByStatusQueryParams) => [{ url: '/pet/findByStatus' }, ...(params ? [params] : [])] as const

export type FindPetsByStatusQueryKey = ReturnType<typeof findPetsByStatusQueryKey>

/**
 * @description Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 * {@link /pet/findByStatus}
 */
export async function findPetsByStatus(params?: FindPetsByStatusQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<FindPetsByStatusResponseData, ResponseErrorConfig<FindPetsByStatusStatus400>, unknown>({
    method: 'GET',
    url: '/pet/findByStatus',
    params,
    ...requestConfig,
  })
  return res.data
}

export function findPetsByStatusQueryOptions(params?: FindPetsByStatusQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = findPetsByStatusQueryKey(params)
  return queryOptions<FindPetsByStatusResponseData, ResponseErrorConfig<FindPetsByStatusStatus400>, FindPetsByStatusResponseData, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return findPetsByStatus(params, config)
    },
  })
}

/**
 * @description Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 * {@link /pet/findByStatus}
 */
export function useFindPetsByStatus<
  TData = FindPetsByStatusResponseData,
  TQueryData = FindPetsByStatusResponseData,
  TQueryKey extends QueryKey = FindPetsByStatusQueryKey,
>(
  params?: FindPetsByStatusQueryParams,
  options: {
    query?: Partial<QueryObserverOptions<FindPetsByStatusResponseData, ResponseErrorConfig<FindPetsByStatusStatus400>, TData, TQueryData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? findPetsByStatusQueryKey(params)

  const query = useQuery(
    {
      ...findPetsByStatusQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<FindPetsByStatusStatus400>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const findPetsByTagsQueryKey = (params?: FindPetsByTagsQueryParams) => [{ url: '/pet/findByTags' }, ...(params ? [params] : [])] as const

export type FindPetsByTagsQueryKey = ReturnType<typeof findPetsByTagsQueryKey>

/**
 * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @summary Finds Pets by tags
 * {@link /pet/findByTags}
 */
export async function findPetsByTags(params?: FindPetsByTagsQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<FindPetsByTagsResponseData, ResponseErrorConfig<FindPetsByTagsStatus400>, unknown>({
    method: 'GET',
    url: '/pet/findByTags',
    params,
    ...requestConfig,
  })
  return res.data
}

export function findPetsByTagsQueryOptions(params?: FindPetsByTagsQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = findPetsByTagsQueryKey(params)
  return queryOptions<FindPetsByTagsResponseData, ResponseErrorConfig<FindPetsByTagsStatus400>, FindPetsByTagsResponseData, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return findPetsByTags(params, config)
    },
  })
}

/**
 * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @summary Finds Pets by tags
 * {@link /pet/findByTags}
 */
export function useFindPetsByTags<
  TData = FindPetsByTagsResponseData,
  TQueryData = FindPetsByTagsResponseData,
  TQueryKey extends QueryKey = FindPetsByTagsQueryKey,
>(
  params?: FindPetsByTagsQueryParams,
  options: {
    query?: Partial<QueryObserverOptions<FindPetsByTagsResponseData, ResponseErrorConfig<FindPetsByTagsStatus400>, TData, TQueryData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? findPetsByTagsQueryKey(params)

  const query = useQuery(
    {
      ...findPetsByTagsQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<FindPetsByTagsStatus400>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getPetByIdQueryKey = (petId: GetPetByIdPathParams['petId']) => [{ url: '/pet/:petId', params: { petId: petId } }] as const

export type GetPetByIdQueryKey = ReturnType<typeof getPetByIdQueryKey>

/**
 * @description Returns a single pet
 * @summary Find pet by ID
 * {@link /pet/:petId}
 */
export async function getPetById(petId: GetPetByIdPathParams['petId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetPetByIdResponseData, ResponseErrorConfig<GetPetByIdStatus400 | GetPetByIdStatus404>, unknown>({
    method: 'GET',
    url: `/pet/${petId}`,
    ...requestConfig,
  })
  return res.data
}

export function getPetByIdQueryOptions(petId: GetPetByIdPathParams['petId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getPetByIdQueryKey(petId)
  return queryOptions<GetPetByIdResponseData, ResponseErrorConfig<GetPetByIdStatus400 | GetPetByIdStatus404>, GetPetByIdResponseData, typeof queryKey>({
    enabled: !!petId,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getPetById(petId, config)
    },
  })
}

/**
 * @description Returns a single pet
 * @summary Find pet by ID
 * {@link /pet/:petId}
 */
export function useGetPetById<TData = GetPetByIdResponseData, TQueryData = GetPetByIdResponseData, TQueryKey extends QueryKey = GetPetByIdQueryKey>(
  petId: GetPetByIdPathParams['petId'],
  options: {
    query?: Partial<
      QueryObserverOptions<GetPetByIdResponseData, ResponseErrorConfig<GetPetByIdStatus400 | GetPetByIdStatus404>, TData, TQueryData, TQueryKey>
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getPetByIdQueryKey(petId)

  const query = useQuery(
    {
      ...getPetByIdQueryOptions(petId, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<GetPetByIdStatus400 | GetPetByIdStatus404>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getInventoryQueryKey = () => [{ url: '/store/inventory' }] as const

export type GetInventoryQueryKey = ReturnType<typeof getInventoryQueryKey>

/**
 * @description Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 * {@link /store/inventory}
 */
export async function getInventory(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetInventoryResponseData, ResponseErrorConfig<Error>, unknown>({ method: 'GET', url: '/store/inventory', ...requestConfig })
  return res.data
}

export function getInventoryQueryOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getInventoryQueryKey()
  return queryOptions<GetInventoryResponseData, ResponseErrorConfig<Error>, GetInventoryResponseData, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getInventory(config)
    },
  })
}

/**
 * @description Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 * {@link /store/inventory}
 */
export function useGetInventory<TData = GetInventoryResponseData, TQueryData = GetInventoryResponseData, TQueryKey extends QueryKey = GetInventoryQueryKey>(
  options: {
    query?: Partial<QueryObserverOptions<GetInventoryResponseData, ResponseErrorConfig<Error>, TData, TQueryData, TQueryKey>> & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getInventoryQueryKey()

  const query = useQuery(
    {
      ...getInventoryQueryOptions(config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<Error>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getOrderByIdQueryKey = (orderId: GetOrderByIdPathParams['orderId']) => [{ url: '/store/order/:orderId', params: { orderId: orderId } }] as const

export type GetOrderByIdQueryKey = ReturnType<typeof getOrderByIdQueryKey>

/**
 * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
 * @summary Find purchase order by ID
 * {@link /store/order/:orderId}
 */
export async function getOrderById(orderId: GetOrderByIdPathParams['orderId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetOrderByIdResponseData, ResponseErrorConfig<GetOrderByIdStatus400 | GetOrderByIdStatus404>, unknown>({
    method: 'GET',
    url: `/store/order/${orderId}`,
    ...requestConfig,
  })
  return res.data
}

export function getOrderByIdQueryOptions(orderId: GetOrderByIdPathParams['orderId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getOrderByIdQueryKey(orderId)
  return queryOptions<GetOrderByIdResponseData, ResponseErrorConfig<GetOrderByIdStatus400 | GetOrderByIdStatus404>, GetOrderByIdResponseData, typeof queryKey>({
    enabled: !!orderId,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getOrderById(orderId, config)
    },
  })
}

/**
 * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
 * @summary Find purchase order by ID
 * {@link /store/order/:orderId}
 */
export function useGetOrderById<TData = GetOrderByIdResponseData, TQueryData = GetOrderByIdResponseData, TQueryKey extends QueryKey = GetOrderByIdQueryKey>(
  orderId: GetOrderByIdPathParams['orderId'],
  options: {
    query?: Partial<
      QueryObserverOptions<GetOrderByIdResponseData, ResponseErrorConfig<GetOrderByIdStatus400 | GetOrderByIdStatus404>, TData, TQueryData, TQueryKey>
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getOrderByIdQueryKey(orderId)

  const query = useQuery(
    {
      ...getOrderByIdQueryOptions(orderId, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<GetOrderByIdStatus400 | GetOrderByIdStatus404>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const loginUserQueryKey = (params?: LoginUserQueryParams) => [{ url: '/user/login' }, ...(params ? [params] : [])] as const

export type LoginUserQueryKey = ReturnType<typeof loginUserQueryKey>

/**
 * @summary Logs user into the system
 * {@link /user/login}
 */
export async function loginUser(params?: LoginUserQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<LoginUserResponseData, ResponseErrorConfig<LoginUserStatus400>, unknown>({
    method: 'GET',
    url: '/user/login',
    params,
    ...requestConfig,
  })
  return res.data
}

export function loginUserQueryOptions(params?: LoginUserQueryParams, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = loginUserQueryKey(params)
  return queryOptions<LoginUserResponseData, ResponseErrorConfig<LoginUserStatus400>, LoginUserResponseData, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return loginUser(params, config)
    },
  })
}

/**
 * @summary Logs user into the system
 * {@link /user/login}
 */
export function useLoginUser<TData = LoginUserResponseData, TQueryData = LoginUserResponseData, TQueryKey extends QueryKey = LoginUserQueryKey>(
  params?: LoginUserQueryParams,
  options: {
    query?: Partial<QueryObserverOptions<LoginUserResponseData, ResponseErrorConfig<LoginUserStatus400>, TData, TQueryData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? loginUserQueryKey(params)

  const query = useQuery(
    {
      ...loginUserQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<LoginUserStatus400>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const logoutUserQueryKey = () => [{ url: '/user/logout' }] as const

export type LogoutUserQueryKey = ReturnType<typeof logoutUserQueryKey>

/**
 * @summary Logs out current logged in user session
 * {@link /user/logout}
 */
export async function logoutUser(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<LogoutUserResponseData, ResponseErrorConfig<Error>, unknown>({ method: 'GET', url: '/user/logout', ...requestConfig })
  return res.data
}

export function logoutUserQueryOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = logoutUserQueryKey()
  return queryOptions<LogoutUserResponseData, ResponseErrorConfig<Error>, LogoutUserResponseData, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return logoutUser(config)
    },
  })
}

/**
 * @summary Logs out current logged in user session
 * {@link /user/logout}
 */
export function useLogoutUser<TData = LogoutUserResponseData, TQueryData = LogoutUserResponseData, TQueryKey extends QueryKey = LogoutUserQueryKey>(
  options: {
    query?: Partial<QueryObserverOptions<LogoutUserResponseData, ResponseErrorConfig<Error>, TData, TQueryData, TQueryKey>> & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? logoutUserQueryKey()

  const query = useQuery(
    {
      ...logoutUserQueryOptions(config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<Error>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getUserByNameQueryKey = (username: GetUserByNamePathParams['username']) => [{ url: '/user/:username', params: { username: username } }] as const

export type GetUserByNameQueryKey = ReturnType<typeof getUserByNameQueryKey>

/**
 * @summary Get user by user name
 * {@link /user/:username}
 */
export async function getUserByName(username: GetUserByNamePathParams['username'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetUserByNameResponseData, ResponseErrorConfig<GetUserByNameStatus400 | GetUserByNameStatus404>, unknown>({
    method: 'GET',
    url: `/user/${username}`,
    ...requestConfig,
  })
  return res.data
}

export function getUserByNameQueryOptions(username: GetUserByNamePathParams['username'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getUserByNameQueryKey(username)
  return queryOptions<
    GetUserByNameResponseData,
    ResponseErrorConfig<GetUserByNameStatus400 | GetUserByNameStatus404>,
    GetUserByNameResponseData,
    typeof queryKey
  >({
    enabled: !!username,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getUserByName(username, config)
    },
  })
}

/**
 * @summary Get user by user name
 * {@link /user/:username}
 */
export function useGetUserByName<TData = GetUserByNameResponseData, TQueryData = GetUserByNameResponseData, TQueryKey extends QueryKey = GetUserByNameQueryKey>(
  username: GetUserByNamePathParams['username'],
  options: {
    query?: Partial<
      QueryObserverOptions<GetUserByNameResponseData, ResponseErrorConfig<GetUserByNameStatus400 | GetUserByNameStatus404>, TData, TQueryData, TQueryKey>
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getUserByNameQueryKey(username)

  const query = useQuery(
    {
      ...getUserByNameQueryOptions(username, config),
      queryKey,
      ...queryOptions,
    } as unknown as QueryObserverOptions,
    queryClient,
  ) as UseQueryResult<TData, ResponseErrorConfig<GetUserByNameStatus400 | GetUserByNameStatus404>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const findPetsByStatusSuspenseQueryKey = (params?: FindPetsByStatusQueryParams3) => [{ url: '/pet/findByStatus' }, ...(params ? [params] : [])] as const

export type FindPetsByStatusSuspenseQueryKey = ReturnType<typeof findPetsByStatusSuspenseQueryKey>

/**
 * @description Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 * {@link /pet/findByStatus}
 */
export async function findPetsByStatusSuspense(params?: FindPetsByStatusQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<FindPetsByStatusResponseData3, ResponseErrorConfig<FindPetsByStatusStatus4003>, unknown>({
    method: 'GET',
    url: '/pet/findByStatus',
    params,
    ...requestConfig,
  })
  return res.data
}

export function findPetsByStatusSuspenseQueryOptions(params?: FindPetsByStatusQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = findPetsByStatusSuspenseQueryKey(params)
  return queryOptions<FindPetsByStatusResponseData3, ResponseErrorConfig<FindPetsByStatusStatus4003>, FindPetsByStatusResponseData3, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return findPetsByStatusSuspense(params, config)
    },
  })
}

/**
 * @description Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 * {@link /pet/findByStatus}
 */
export function useFindPetsByStatusSuspense<TData = FindPetsByStatusResponseData3, TQueryKey extends QueryKey = FindPetsByStatusSuspenseQueryKey>(
  params?: FindPetsByStatusQueryParams3,
  options: {
    query?: Partial<UseSuspenseQueryOptions<FindPetsByStatusResponseData3, ResponseErrorConfig<FindPetsByStatusStatus4003>, TData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? findPetsByStatusSuspenseQueryKey(params)

  const query = useSuspenseQuery(
    {
      ...findPetsByStatusSuspenseQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<FindPetsByStatusStatus4003>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const findPetsByTagsSuspenseQueryKey = (params?: FindPetsByTagsQueryParams3) => [{ url: '/pet/findByTags' }, ...(params ? [params] : [])] as const

export type FindPetsByTagsSuspenseQueryKey = ReturnType<typeof findPetsByTagsSuspenseQueryKey>

/**
 * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @summary Finds Pets by tags
 * {@link /pet/findByTags}
 */
export async function findPetsByTagsSuspense(params?: FindPetsByTagsQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<FindPetsByTagsResponseData3, ResponseErrorConfig<FindPetsByTagsStatus4003>, unknown>({
    method: 'GET',
    url: '/pet/findByTags',
    params,
    ...requestConfig,
  })
  return res.data
}

export function findPetsByTagsSuspenseQueryOptions(params?: FindPetsByTagsQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = findPetsByTagsSuspenseQueryKey(params)
  return queryOptions<FindPetsByTagsResponseData3, ResponseErrorConfig<FindPetsByTagsStatus4003>, FindPetsByTagsResponseData3, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return findPetsByTagsSuspense(params, config)
    },
  })
}

/**
 * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @summary Finds Pets by tags
 * {@link /pet/findByTags}
 */
export function useFindPetsByTagsSuspense<TData = FindPetsByTagsResponseData3, TQueryKey extends QueryKey = FindPetsByTagsSuspenseQueryKey>(
  params?: FindPetsByTagsQueryParams3,
  options: {
    query?: Partial<UseSuspenseQueryOptions<FindPetsByTagsResponseData3, ResponseErrorConfig<FindPetsByTagsStatus4003>, TData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? findPetsByTagsSuspenseQueryKey(params)

  const query = useSuspenseQuery(
    {
      ...findPetsByTagsSuspenseQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<FindPetsByTagsStatus4003>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getPetByIdSuspenseQueryKey = (petId: GetPetByIdPathParams3['petId']) => [{ url: '/pet/:petId', params: { petId: petId } }] as const

export type GetPetByIdSuspenseQueryKey = ReturnType<typeof getPetByIdSuspenseQueryKey>

/**
 * @description Returns a single pet
 * @summary Find pet by ID
 * {@link /pet/:petId}
 */
export async function getPetByIdSuspense(petId: GetPetByIdPathParams3['petId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetPetByIdResponseData3, ResponseErrorConfig<GetPetByIdStatus4003 | GetPetByIdStatus4043>, unknown>({
    method: 'GET',
    url: `/pet/${petId}`,
    ...requestConfig,
  })
  return res.data
}

export function getPetByIdSuspenseQueryOptions(petId: GetPetByIdPathParams3['petId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getPetByIdSuspenseQueryKey(petId)
  return queryOptions<GetPetByIdResponseData3, ResponseErrorConfig<GetPetByIdStatus4003 | GetPetByIdStatus4043>, GetPetByIdResponseData3, typeof queryKey>({
    enabled: !!petId,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getPetByIdSuspense(petId, config)
    },
  })
}

/**
 * @description Returns a single pet
 * @summary Find pet by ID
 * {@link /pet/:petId}
 */
export function useGetPetByIdSuspense<TData = GetPetByIdResponseData3, TQueryKey extends QueryKey = GetPetByIdSuspenseQueryKey>(
  petId: GetPetByIdPathParams3['petId'],
  options: {
    query?: Partial<UseSuspenseQueryOptions<GetPetByIdResponseData3, ResponseErrorConfig<GetPetByIdStatus4003 | GetPetByIdStatus4043>, TData, TQueryKey>> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getPetByIdSuspenseQueryKey(petId)

  const query = useSuspenseQuery(
    {
      ...getPetByIdSuspenseQueryOptions(petId, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<GetPetByIdStatus4003 | GetPetByIdStatus4043>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getInventorySuspenseQueryKey = () => [{ url: '/store/inventory' }] as const

export type GetInventorySuspenseQueryKey = ReturnType<typeof getInventorySuspenseQueryKey>

/**
 * @description Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 * {@link /store/inventory}
 */
export async function getInventorySuspense(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetInventoryResponseData3, ResponseErrorConfig<Error>, unknown>({ method: 'GET', url: '/store/inventory', ...requestConfig })
  return res.data
}

export function getInventorySuspenseQueryOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getInventorySuspenseQueryKey()
  return queryOptions<GetInventoryResponseData3, ResponseErrorConfig<Error>, GetInventoryResponseData3, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getInventorySuspense(config)
    },
  })
}

/**
 * @description Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 * {@link /store/inventory}
 */
export function useGetInventorySuspense<TData = GetInventoryResponseData3, TQueryKey extends QueryKey = GetInventorySuspenseQueryKey>(
  options: {
    query?: Partial<UseSuspenseQueryOptions<GetInventoryResponseData3, ResponseErrorConfig<Error>, TData, TQueryKey>> & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getInventorySuspenseQueryKey()

  const query = useSuspenseQuery(
    {
      ...getInventorySuspenseQueryOptions(config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<Error>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getOrderByIdSuspenseQueryKey = (orderId: GetOrderByIdPathParams3['orderId']) =>
  [{ url: '/store/order/:orderId', params: { orderId: orderId } }] as const

export type GetOrderByIdSuspenseQueryKey = ReturnType<typeof getOrderByIdSuspenseQueryKey>

/**
 * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
 * @summary Find purchase order by ID
 * {@link /store/order/:orderId}
 */
export async function getOrderByIdSuspense(orderId: GetOrderByIdPathParams3['orderId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetOrderByIdResponseData3, ResponseErrorConfig<GetOrderByIdStatus4003 | GetOrderByIdStatus4043>, unknown>({
    method: 'GET',
    url: `/store/order/${orderId}`,
    ...requestConfig,
  })
  return res.data
}

export function getOrderByIdSuspenseQueryOptions(orderId: GetOrderByIdPathParams3['orderId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = getOrderByIdSuspenseQueryKey(orderId)
  return queryOptions<
    GetOrderByIdResponseData3,
    ResponseErrorConfig<GetOrderByIdStatus4003 | GetOrderByIdStatus4043>,
    GetOrderByIdResponseData3,
    typeof queryKey
  >({
    enabled: !!orderId,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getOrderByIdSuspense(orderId, config)
    },
  })
}

/**
 * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
 * @summary Find purchase order by ID
 * {@link /store/order/:orderId}
 */
export function useGetOrderByIdSuspense<TData = GetOrderByIdResponseData3, TQueryKey extends QueryKey = GetOrderByIdSuspenseQueryKey>(
  orderId: GetOrderByIdPathParams3['orderId'],
  options: {
    query?: Partial<
      UseSuspenseQueryOptions<GetOrderByIdResponseData3, ResponseErrorConfig<GetOrderByIdStatus4003 | GetOrderByIdStatus4043>, TData, TQueryKey>
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getOrderByIdSuspenseQueryKey(orderId)

  const query = useSuspenseQuery(
    {
      ...getOrderByIdSuspenseQueryOptions(orderId, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<GetOrderByIdStatus4003 | GetOrderByIdStatus4043>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const loginUserSuspenseQueryKey = (params?: LoginUserQueryParams3) => [{ url: '/user/login' }, ...(params ? [params] : [])] as const

export type LoginUserSuspenseQueryKey = ReturnType<typeof loginUserSuspenseQueryKey>

/**
 * @summary Logs user into the system
 * {@link /user/login}
 */
export async function loginUserSuspense(params?: LoginUserQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<LoginUserResponseData3, ResponseErrorConfig<LoginUserStatus4003>, unknown>({
    method: 'GET',
    url: '/user/login',
    params,
    ...requestConfig,
  })
  return res.data
}

export function loginUserSuspenseQueryOptions(params?: LoginUserQueryParams3, config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = loginUserSuspenseQueryKey(params)
  return queryOptions<LoginUserResponseData3, ResponseErrorConfig<LoginUserStatus4003>, LoginUserResponseData3, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return loginUserSuspense(params, config)
    },
  })
}

/**
 * @summary Logs user into the system
 * {@link /user/login}
 */
export function useLoginUserSuspense<TData = LoginUserResponseData3, TQueryKey extends QueryKey = LoginUserSuspenseQueryKey>(
  params?: LoginUserQueryParams3,
  options: {
    query?: Partial<UseSuspenseQueryOptions<LoginUserResponseData3, ResponseErrorConfig<LoginUserStatus4003>, TData, TQueryKey>> & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? loginUserSuspenseQueryKey(params)

  const query = useSuspenseQuery(
    {
      ...loginUserSuspenseQueryOptions(params, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<LoginUserStatus4003>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const logoutUserSuspenseQueryKey = () => [{ url: '/user/logout' }] as const

export type LogoutUserSuspenseQueryKey = ReturnType<typeof logoutUserSuspenseQueryKey>

/**
 * @summary Logs out current logged in user session
 * {@link /user/logout}
 */
export async function logoutUserSuspense(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<LogoutUserResponseData3, ResponseErrorConfig<Error>, unknown>({ method: 'GET', url: '/user/logout', ...requestConfig })
  return res.data
}

export function logoutUserSuspenseQueryOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const queryKey = logoutUserSuspenseQueryKey()
  return queryOptions<LogoutUserResponseData3, ResponseErrorConfig<Error>, LogoutUserResponseData3, typeof queryKey>({
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return logoutUserSuspense(config)
    },
  })
}

/**
 * @summary Logs out current logged in user session
 * {@link /user/logout}
 */
export function useLogoutUserSuspense<TData = LogoutUserResponseData3, TQueryKey extends QueryKey = LogoutUserSuspenseQueryKey>(
  options: {
    query?: Partial<UseSuspenseQueryOptions<LogoutUserResponseData3, ResponseErrorConfig<Error>, TData, TQueryKey>> & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? logoutUserSuspenseQueryKey()

  const query = useSuspenseQuery(
    {
      ...logoutUserSuspenseQueryOptions(config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<Error>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const getUserByNameSuspenseQueryKey = (username: GetUserByNamePathParams3['username']) =>
  [{ url: '/user/:username', params: { username: username } }] as const

export type GetUserByNameSuspenseQueryKey = ReturnType<typeof getUserByNameSuspenseQueryKey>

/**
 * @summary Get user by user name
 * {@link /user/:username}
 */
export async function getUserByNameSuspense(username: GetUserByNamePathParams3['username'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<GetUserByNameResponseData3, ResponseErrorConfig<GetUserByNameStatus4003 | GetUserByNameStatus4043>, unknown>({
    method: 'GET',
    url: `/user/${username}`,
    ...requestConfig,
  })
  return res.data
}

export function getUserByNameSuspenseQueryOptions(
  username: GetUserByNamePathParams3['username'],
  config: Partial<RequestConfig> & { client?: typeof fetch } = {},
) {
  const queryKey = getUserByNameSuspenseQueryKey(username)
  return queryOptions<
    GetUserByNameResponseData3,
    ResponseErrorConfig<GetUserByNameStatus4003 | GetUserByNameStatus4043>,
    GetUserByNameResponseData3,
    typeof queryKey
  >({
    enabled: !!username,
    queryKey,
    queryFn: async ({ signal }) => {
      config.signal = signal
      return getUserByNameSuspense(username, config)
    },
  })
}

/**
 * @summary Get user by user name
 * {@link /user/:username}
 */
export function useGetUserByNameSuspense<TData = GetUserByNameResponseData3, TQueryKey extends QueryKey = GetUserByNameSuspenseQueryKey>(
  username: GetUserByNamePathParams3['username'],
  options: {
    query?: Partial<
      UseSuspenseQueryOptions<GetUserByNameResponseData3, ResponseErrorConfig<GetUserByNameStatus4003 | GetUserByNameStatus4043>, TData, TQueryKey>
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { query: queryConfig = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...queryOptions } = queryConfig
  const queryKey = queryOptions?.queryKey ?? getUserByNameSuspenseQueryKey(username)

  const query = useSuspenseQuery(
    {
      ...getUserByNameSuspenseQueryOptions(username, config),
      queryKey,
      ...queryOptions,
    } as unknown as UseSuspenseQueryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, ResponseErrorConfig<GetUserByNameStatus4003 | GetUserByNameStatus4043>> & { queryKey: TQueryKey }

  query.queryKey = queryKey as TQueryKey

  return query
}

export const updatePetMutationKey = () => [{ url: '/pet' }] as const

export type UpdatePetMutationKey = ReturnType<typeof updatePetMutationKey>

/**
 * @description Update an existing pet by Id
 * @summary Update an existing pet
 * {@link /pet}
 */
export async function updatePet(data: UpdatePetRequestData9, config: Partial<RequestConfig<UpdatePetRequestData9>> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<
    UpdatePetResponseData9,
    ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
    UpdatePetRequestData9
  >({ method: 'PUT', url: '/pet', data: requestData, ...requestConfig })
  return res.data
}

export function updatePetMutationOptions(config: Partial<RequestConfig<UpdatePetRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = updatePetMutationKey()
  return mutationOptions<
    UpdatePetResponseData9,
    ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
    { data: UpdatePetRequestData9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ data }) => {
      return updatePet(data, config)
    },
  })
}

/**
 * @description Update an existing pet by Id
 * @summary Update an existing pet
 * {@link /pet}
 */
export function useUpdatePet<TContext>(
  options: {
    mutation?: UseMutationOptions<
      UpdatePetResponseData9,
      ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
      { data: UpdatePetRequestData9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig<UpdatePetRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? updatePetMutationKey()

  const baseOptions = updatePetMutationOptions(config) as UseMutationOptions<
    UpdatePetResponseData9,
    ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
    { data: UpdatePetRequestData9 },
    TContext
  >

  return useMutation<
    UpdatePetResponseData9,
    ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
    { data: UpdatePetRequestData9 },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    UpdatePetResponseData9,
    ResponseErrorConfig<UpdatePetStatus4009 | UpdatePetStatus4049 | UpdatePetStatus4059>,
    { data: UpdatePetRequestData9 },
    TContext
  >
}

export const addPetMutationKey = () => [{ url: '/pet' }] as const

export type AddPetMutationKey = ReturnType<typeof addPetMutationKey>

/**
 * @description Add a new pet to the store
 * @summary Add a new pet to the store
 * {@link /pet}
 */
export async function addPet(data: AddPetRequestData9, config: Partial<RequestConfig<AddPetRequestData9>> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<AddPetResponseData9, ResponseErrorConfig<AddPetStatus4059>, AddPetRequestData9>({
    method: 'POST',
    url: '/pet',
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function addPetMutationOptions(config: Partial<RequestConfig<AddPetRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = addPetMutationKey()
  return mutationOptions<AddPetResponseData9, ResponseErrorConfig<AddPetStatus4059>, { data: AddPetRequestData9 }, typeof mutationKey>({
    mutationKey,
    mutationFn: async ({ data }) => {
      return addPet(data, config)
    },
  })
}

/**
 * @description Add a new pet to the store
 * @summary Add a new pet to the store
 * {@link /pet}
 */
export function useAddPet<TContext>(
  options: {
    mutation?: UseMutationOptions<AddPetResponseData9, ResponseErrorConfig<AddPetStatus4059>, { data: AddPetRequestData9 }, TContext> & { client?: QueryClient }
    client?: Partial<RequestConfig<AddPetRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? addPetMutationKey()

  const baseOptions = addPetMutationOptions(config) as UseMutationOptions<
    AddPetResponseData9,
    ResponseErrorConfig<AddPetStatus4059>,
    { data: AddPetRequestData9 },
    TContext
  >

  return useMutation<AddPetResponseData9, ResponseErrorConfig<AddPetStatus4059>, { data: AddPetRequestData9 }, TContext>(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<AddPetResponseData9, ResponseErrorConfig<AddPetStatus4059>, { data: AddPetRequestData9 }, TContext>
}

export const updatePetWithFormMutationKey = () => [{ url: '/pet/:petId' }] as const

export type UpdatePetWithFormMutationKey = ReturnType<typeof updatePetWithFormMutationKey>

/**
 * @summary Updates a pet in the store with form data
 * {@link /pet/:petId}
 */
export async function updatePetWithForm(
  petId: UpdatePetWithFormPathParams9['petId'],
  params?: UpdatePetWithFormQueryParams9,
  config: Partial<RequestConfig> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<UpdatePetWithFormResponseData9, ResponseErrorConfig<UpdatePetWithFormStatus4059>, unknown>({
    method: 'POST',
    url: `/pet/${petId}`,
    params,
    ...requestConfig,
  })
  return res.data
}

export function updatePetWithFormMutationOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const mutationKey = updatePetWithFormMutationKey()
  return mutationOptions<
    UpdatePetWithFormResponseData9,
    ResponseErrorConfig<UpdatePetWithFormStatus4059>,
    { petId: UpdatePetWithFormPathParams9['petId']; params?: UpdatePetWithFormQueryParams9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ petId, params }) => {
      return updatePetWithForm(petId, params, config)
    },
  })
}

/**
 * @summary Updates a pet in the store with form data
 * {@link /pet/:petId}
 */
export function useUpdatePetWithForm<TContext>(
  options: {
    mutation?: UseMutationOptions<
      UpdatePetWithFormResponseData9,
      ResponseErrorConfig<UpdatePetWithFormStatus4059>,
      { petId: UpdatePetWithFormPathParams9['petId']; params?: UpdatePetWithFormQueryParams9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? updatePetWithFormMutationKey()

  const baseOptions = updatePetWithFormMutationOptions(config) as UseMutationOptions<
    UpdatePetWithFormResponseData9,
    ResponseErrorConfig<UpdatePetWithFormStatus4059>,
    { petId: UpdatePetWithFormPathParams9['petId']; params?: UpdatePetWithFormQueryParams9 },
    TContext
  >

  return useMutation<
    UpdatePetWithFormResponseData9,
    ResponseErrorConfig<UpdatePetWithFormStatus4059>,
    { petId: UpdatePetWithFormPathParams9['petId']; params?: UpdatePetWithFormQueryParams9 },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    UpdatePetWithFormResponseData9,
    ResponseErrorConfig<UpdatePetWithFormStatus4059>,
    { petId: UpdatePetWithFormPathParams9['petId']; params?: UpdatePetWithFormQueryParams9 },
    TContext
  >
}

export const deletePetMutationKey = () => [{ url: '/pet/:petId' }] as const

export type DeletePetMutationKey = ReturnType<typeof deletePetMutationKey>

/**
 * @description delete a pet
 * @summary Deletes a pet
 * {@link /pet/:petId}
 */
export async function deletePet(
  petId: DeletePetPathParams9['petId'],
  headers?: DeletePetHeaderParams9,
  config: Partial<RequestConfig> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<DeletePetResponseData9, ResponseErrorConfig<DeletePetStatus4009>, unknown>({
    method: 'DELETE',
    url: `/pet/${petId}`,
    ...requestConfig,
    headers: { ...headers, ...requestConfig.headers },
  })
  return res.data
}

export function deletePetMutationOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const mutationKey = deletePetMutationKey()
  return mutationOptions<
    DeletePetResponseData9,
    ResponseErrorConfig<DeletePetStatus4009>,
    { petId: DeletePetPathParams9['petId']; headers?: DeletePetHeaderParams9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ petId, headers }) => {
      return deletePet(petId, headers, config)
    },
  })
}

/**
 * @description delete a pet
 * @summary Deletes a pet
 * {@link /pet/:petId}
 */
export function useDeletePet<TContext>(
  options: {
    mutation?: UseMutationOptions<
      DeletePetResponseData9,
      ResponseErrorConfig<DeletePetStatus4009>,
      { petId: DeletePetPathParams9['petId']; headers?: DeletePetHeaderParams9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? deletePetMutationKey()

  const baseOptions = deletePetMutationOptions(config) as UseMutationOptions<
    DeletePetResponseData9,
    ResponseErrorConfig<DeletePetStatus4009>,
    { petId: DeletePetPathParams9['petId']; headers?: DeletePetHeaderParams9 },
    TContext
  >

  return useMutation<
    DeletePetResponseData9,
    ResponseErrorConfig<DeletePetStatus4009>,
    { petId: DeletePetPathParams9['petId']; headers?: DeletePetHeaderParams9 },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    DeletePetResponseData9,
    ResponseErrorConfig<DeletePetStatus4009>,
    { petId: DeletePetPathParams9['petId']; headers?: DeletePetHeaderParams9 },
    TContext
  >
}

export const uploadFileMutationKey = () => [{ url: '/pet/:petId/uploadImage' }] as const

export type UploadFileMutationKey = ReturnType<typeof uploadFileMutationKey>

/**
 * @summary uploads an image
 * {@link /pet/:petId/uploadImage}
 */
export async function uploadFile(
  petId: UploadFilePathParams9['petId'],
  data?: UploadFileRequestData9,
  params?: UploadFileQueryParams9,
  config: Partial<RequestConfig<UploadFileRequestData9>> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<UploadFileResponseData9, ResponseErrorConfig<Error>, UploadFileRequestData9>({
    method: 'POST',
    url: `/pet/${petId}/uploadImage`,
    params,
    data: requestData,
    ...requestConfig,
    headers: { 'Content-Type': 'application/octet-stream', ...requestConfig.headers },
  })
  return res.data
}

export function uploadFileMutationOptions(config: Partial<RequestConfig<UploadFileRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = uploadFileMutationKey()
  return mutationOptions<
    UploadFileResponseData9,
    ResponseErrorConfig<Error>,
    { petId: UploadFilePathParams9['petId']; data?: UploadFileRequestData9; params?: UploadFileQueryParams9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ petId, data, params }) => {
      return uploadFile(petId, data, params, config)
    },
  })
}

/**
 * @summary uploads an image
 * {@link /pet/:petId/uploadImage}
 */
export function useUploadFile<TContext>(
  options: {
    mutation?: UseMutationOptions<
      UploadFileResponseData9,
      ResponseErrorConfig<Error>,
      { petId: UploadFilePathParams9['petId']; data?: UploadFileRequestData9; params?: UploadFileQueryParams9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig<UploadFileRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? uploadFileMutationKey()

  const baseOptions = uploadFileMutationOptions(config) as UseMutationOptions<
    UploadFileResponseData9,
    ResponseErrorConfig<Error>,
    { petId: UploadFilePathParams9['petId']; data?: UploadFileRequestData9; params?: UploadFileQueryParams9 },
    TContext
  >

  return useMutation<
    UploadFileResponseData9,
    ResponseErrorConfig<Error>,
    { petId: UploadFilePathParams9['petId']; data?: UploadFileRequestData9; params?: UploadFileQueryParams9 },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    UploadFileResponseData9,
    ResponseErrorConfig<Error>,
    { petId: UploadFilePathParams9['petId']; data?: UploadFileRequestData9; params?: UploadFileQueryParams9 },
    TContext
  >
}

export const placeOrderMutationKey = () => [{ url: '/store/order' }] as const

export type PlaceOrderMutationKey = ReturnType<typeof placeOrderMutationKey>

/**
 * @description Place a new order in the store
 * @summary Place an order for a pet
 * {@link /store/order}
 */
export async function placeOrder(data?: PlaceOrderRequestData9, config: Partial<RequestConfig<PlaceOrderRequestData9>> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<PlaceOrderResponseData9, ResponseErrorConfig<PlaceOrderStatus4059>, PlaceOrderRequestData9>({
    method: 'POST',
    url: '/store/order',
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function placeOrderMutationOptions(config: Partial<RequestConfig<PlaceOrderRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = placeOrderMutationKey()
  return mutationOptions<PlaceOrderResponseData9, ResponseErrorConfig<PlaceOrderStatus4059>, { data?: PlaceOrderRequestData9 }, typeof mutationKey>({
    mutationKey,
    mutationFn: async ({ data }) => {
      return placeOrder(data, config)
    },
  })
}

/**
 * @description Place a new order in the store
 * @summary Place an order for a pet
 * {@link /store/order}
 */
export function usePlaceOrder<TContext>(
  options: {
    mutation?: UseMutationOptions<PlaceOrderResponseData9, ResponseErrorConfig<PlaceOrderStatus4059>, { data?: PlaceOrderRequestData9 }, TContext> & {
      client?: QueryClient
    }
    client?: Partial<RequestConfig<PlaceOrderRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? placeOrderMutationKey()

  const baseOptions = placeOrderMutationOptions(config) as UseMutationOptions<
    PlaceOrderResponseData9,
    ResponseErrorConfig<PlaceOrderStatus4059>,
    { data?: PlaceOrderRequestData9 },
    TContext
  >

  return useMutation<PlaceOrderResponseData9, ResponseErrorConfig<PlaceOrderStatus4059>, { data?: PlaceOrderRequestData9 }, TContext>(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<PlaceOrderResponseData9, ResponseErrorConfig<PlaceOrderStatus4059>, { data?: PlaceOrderRequestData9 }, TContext>
}

export const placeOrderPatchMutationKey = () => [{ url: '/store/order' }] as const

export type PlaceOrderPatchMutationKey = ReturnType<typeof placeOrderPatchMutationKey>

/**
 * @description Place a new order in the store with patch
 * @summary Place an order for a pet with patch
 * {@link /store/order}
 */
export async function placeOrderPatch(
  data?: PlaceOrderPatchRequestData9,
  config: Partial<RequestConfig<PlaceOrderPatchRequestData9>> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<PlaceOrderPatchResponseData9, ResponseErrorConfig<PlaceOrderPatchStatus4059>, PlaceOrderPatchRequestData9>({
    method: 'PATCH',
    url: '/store/order',
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function placeOrderPatchMutationOptions(config: Partial<RequestConfig<PlaceOrderPatchRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = placeOrderPatchMutationKey()
  return mutationOptions<
    PlaceOrderPatchResponseData9,
    ResponseErrorConfig<PlaceOrderPatchStatus4059>,
    { data?: PlaceOrderPatchRequestData9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ data }) => {
      return placeOrderPatch(data, config)
    },
  })
}

/**
 * @description Place a new order in the store with patch
 * @summary Place an order for a pet with patch
 * {@link /store/order}
 */
export function usePlaceOrderPatch<TContext>(
  options: {
    mutation?: UseMutationOptions<
      PlaceOrderPatchResponseData9,
      ResponseErrorConfig<PlaceOrderPatchStatus4059>,
      { data?: PlaceOrderPatchRequestData9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig<PlaceOrderPatchRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? placeOrderPatchMutationKey()

  const baseOptions = placeOrderPatchMutationOptions(config) as UseMutationOptions<
    PlaceOrderPatchResponseData9,
    ResponseErrorConfig<PlaceOrderPatchStatus4059>,
    { data?: PlaceOrderPatchRequestData9 },
    TContext
  >

  return useMutation<PlaceOrderPatchResponseData9, ResponseErrorConfig<PlaceOrderPatchStatus4059>, { data?: PlaceOrderPatchRequestData9 }, TContext>(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<PlaceOrderPatchResponseData9, ResponseErrorConfig<PlaceOrderPatchStatus4059>, { data?: PlaceOrderPatchRequestData9 }, TContext>
}

export const deleteOrderMutationKey = () => [{ url: '/store/order/:orderId' }] as const

export type DeleteOrderMutationKey = ReturnType<typeof deleteOrderMutationKey>

/**
 * @description For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
 * @summary Delete purchase order by ID
 * {@link /store/order/:orderId}
 */
export async function deleteOrder(orderId: DeleteOrderPathParams9['orderId'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<DeleteOrderResponseData9, ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>, unknown>({
    method: 'DELETE',
    url: `/store/order/${orderId}`,
    ...requestConfig,
  })
  return res.data
}

export function deleteOrderMutationOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const mutationKey = deleteOrderMutationKey()
  return mutationOptions<
    DeleteOrderResponseData9,
    ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>,
    { orderId: DeleteOrderPathParams9['orderId'] },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ orderId }) => {
      return deleteOrder(orderId, config)
    },
  })
}

/**
 * @description For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
 * @summary Delete purchase order by ID
 * {@link /store/order/:orderId}
 */
export function useDeleteOrder<TContext>(
  options: {
    mutation?: UseMutationOptions<
      DeleteOrderResponseData9,
      ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>,
      { orderId: DeleteOrderPathParams9['orderId'] },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? deleteOrderMutationKey()

  const baseOptions = deleteOrderMutationOptions(config) as UseMutationOptions<
    DeleteOrderResponseData9,
    ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>,
    { orderId: DeleteOrderPathParams9['orderId'] },
    TContext
  >

  return useMutation<
    DeleteOrderResponseData9,
    ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>,
    { orderId: DeleteOrderPathParams9['orderId'] },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    DeleteOrderResponseData9,
    ResponseErrorConfig<DeleteOrderStatus4009 | DeleteOrderStatus4049>,
    { orderId: DeleteOrderPathParams9['orderId'] },
    TContext
  >
}

export const createUserMutationKey = () => [{ url: '/user' }] as const

export type CreateUserMutationKey = ReturnType<typeof createUserMutationKey>

/**
 * @description This can only be done by the logged in user.
 * @summary Create user
 * {@link /user}
 */
export async function createUser(data?: CreateUserRequestData9, config: Partial<RequestConfig<CreateUserRequestData9>> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<CreateUserResponseData9, ResponseErrorConfig<Error>, CreateUserRequestData9>({
    method: 'POST',
    url: '/user',
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function createUserMutationOptions(config: Partial<RequestConfig<CreateUserRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = createUserMutationKey()
  return mutationOptions<CreateUserResponseData9, ResponseErrorConfig<Error>, { data?: CreateUserRequestData9 }, typeof mutationKey>({
    mutationKey,
    mutationFn: async ({ data }) => {
      return createUser(data, config)
    },
  })
}

/**
 * @description This can only be done by the logged in user.
 * @summary Create user
 * {@link /user}
 */
export function useCreateUser<TContext>(
  options: {
    mutation?: UseMutationOptions<CreateUserResponseData9, ResponseErrorConfig<Error>, { data?: CreateUserRequestData9 }, TContext> & { client?: QueryClient }
    client?: Partial<RequestConfig<CreateUserRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? createUserMutationKey()

  const baseOptions = createUserMutationOptions(config) as UseMutationOptions<
    CreateUserResponseData9,
    ResponseErrorConfig<Error>,
    { data?: CreateUserRequestData9 },
    TContext
  >

  return useMutation<CreateUserResponseData9, ResponseErrorConfig<Error>, { data?: CreateUserRequestData9 }, TContext>(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<CreateUserResponseData9, ResponseErrorConfig<Error>, { data?: CreateUserRequestData9 }, TContext>
}

export const createUsersWithListInputMutationKey = () => [{ url: '/user/createWithList' }] as const

export type CreateUsersWithListInputMutationKey = ReturnType<typeof createUsersWithListInputMutationKey>

/**
 * @description Creates list of users with given input array
 * @summary Creates list of users with given input array
 * {@link /user/createWithList}
 */
export async function createUsersWithListInput(
  data?: CreateUsersWithListInputRequestData9,
  config: Partial<RequestConfig<CreateUsersWithListInputRequestData9>> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<CreateUsersWithListInputResponseData9, ResponseErrorConfig<Error>, CreateUsersWithListInputRequestData9>({
    method: 'POST',
    url: '/user/createWithList',
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function createUsersWithListInputMutationOptions(config: Partial<RequestConfig<CreateUsersWithListInputRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = createUsersWithListInputMutationKey()
  return mutationOptions<
    CreateUsersWithListInputResponseData9,
    ResponseErrorConfig<Error>,
    { data?: CreateUsersWithListInputRequestData9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ data }) => {
      return createUsersWithListInput(data, config)
    },
  })
}

/**
 * @description Creates list of users with given input array
 * @summary Creates list of users with given input array
 * {@link /user/createWithList}
 */
export function useCreateUsersWithListInput<TContext>(
  options: {
    mutation?: UseMutationOptions<
      CreateUsersWithListInputResponseData9,
      ResponseErrorConfig<Error>,
      { data?: CreateUsersWithListInputRequestData9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig<CreateUsersWithListInputRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? createUsersWithListInputMutationKey()

  const baseOptions = createUsersWithListInputMutationOptions(config) as UseMutationOptions<
    CreateUsersWithListInputResponseData9,
    ResponseErrorConfig<Error>,
    { data?: CreateUsersWithListInputRequestData9 },
    TContext
  >

  return useMutation<CreateUsersWithListInputResponseData9, ResponseErrorConfig<Error>, { data?: CreateUsersWithListInputRequestData9 }, TContext>(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<CreateUsersWithListInputResponseData9, ResponseErrorConfig<Error>, { data?: CreateUsersWithListInputRequestData9 }, TContext>
}

export const updateUserMutationKey = () => [{ url: '/user/:username' }] as const

export type UpdateUserMutationKey = ReturnType<typeof updateUserMutationKey>

/**
 * @description This can only be done by the logged in user.
 * @summary Update user
 * {@link /user/:username}
 */
export async function updateUser(
  username: UpdateUserPathParams9['username'],
  data?: UpdateUserRequestData9,
  config: Partial<RequestConfig<UpdateUserRequestData9>> & { client?: typeof fetch } = {},
) {
  const { client: request = fetch, ...requestConfig } = config

  const requestData = data

  const res = await request<UpdateUserResponseData9, ResponseErrorConfig<Error>, UpdateUserRequestData9>({
    method: 'PUT',
    url: `/user/${username}`,
    data: requestData,
    ...requestConfig,
  })
  return res.data
}

export function updateUserMutationOptions(config: Partial<RequestConfig<UpdateUserRequestData9>> & { client?: typeof fetch } = {}) {
  const mutationKey = updateUserMutationKey()
  return mutationOptions<
    UpdateUserResponseData9,
    ResponseErrorConfig<Error>,
    { username: UpdateUserPathParams9['username']; data?: UpdateUserRequestData9 },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ username, data }) => {
      return updateUser(username, data, config)
    },
  })
}

/**
 * @description This can only be done by the logged in user.
 * @summary Update user
 * {@link /user/:username}
 */
export function useUpdateUser<TContext>(
  options: {
    mutation?: UseMutationOptions<
      UpdateUserResponseData9,
      ResponseErrorConfig<Error>,
      { username: UpdateUserPathParams9['username']; data?: UpdateUserRequestData9 },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig<UpdateUserRequestData9>> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? updateUserMutationKey()

  const baseOptions = updateUserMutationOptions(config) as UseMutationOptions<
    UpdateUserResponseData9,
    ResponseErrorConfig<Error>,
    { username: UpdateUserPathParams9['username']; data?: UpdateUserRequestData9 },
    TContext
  >

  return useMutation<
    UpdateUserResponseData9,
    ResponseErrorConfig<Error>,
    { username: UpdateUserPathParams9['username']; data?: UpdateUserRequestData9 },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    UpdateUserResponseData9,
    ResponseErrorConfig<Error>,
    { username: UpdateUserPathParams9['username']; data?: UpdateUserRequestData9 },
    TContext
  >
}

export const deleteUserMutationKey = () => [{ url: '/user/:username' }] as const

export type DeleteUserMutationKey = ReturnType<typeof deleteUserMutationKey>

/**
 * @description This can only be done by the logged in user.
 * @summary Delete user
 * {@link /user/:username}
 */
export async function deleteUser(username: DeleteUserPathParams9['username'], config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const { client: request = fetch, ...requestConfig } = config

  const res = await request<DeleteUserResponseData9, ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>, unknown>({
    method: 'DELETE',
    url: `/user/${username}`,
    ...requestConfig,
  })
  return res.data
}

export function deleteUserMutationOptions(config: Partial<RequestConfig> & { client?: typeof fetch } = {}) {
  const mutationKey = deleteUserMutationKey()
  return mutationOptions<
    DeleteUserResponseData9,
    ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>,
    { username: DeleteUserPathParams9['username'] },
    typeof mutationKey
  >({
    mutationKey,
    mutationFn: async ({ username }) => {
      return deleteUser(username, config)
    },
  })
}

/**
 * @description This can only be done by the logged in user.
 * @summary Delete user
 * {@link /user/:username}
 */
export function useDeleteUser<TContext>(
  options: {
    mutation?: UseMutationOptions<
      DeleteUserResponseData9,
      ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>,
      { username: DeleteUserPathParams9['username'] },
      TContext
    > & { client?: QueryClient }
    client?: Partial<RequestConfig> & { client?: typeof fetch }
  } = {},
) {
  const { mutation = {}, client: config = {} } = options ?? {}
  const { client: queryClient, ...mutationOptions } = mutation
  const mutationKey = mutationOptions.mutationKey ?? deleteUserMutationKey()

  const baseOptions = deleteUserMutationOptions(config) as UseMutationOptions<
    DeleteUserResponseData9,
    ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>,
    { username: DeleteUserPathParams9['username'] },
    TContext
  >

  return useMutation<
    DeleteUserResponseData9,
    ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>,
    { username: DeleteUserPathParams9['username'] },
    TContext
  >(
    {
      ...baseOptions,
      mutationKey,
      ...mutationOptions,
    },
    queryClient,
  ) as UseMutationResult<
    DeleteUserResponseData9,
    ResponseErrorConfig<DeleteUserStatus4009 | DeleteUserStatus4049>,
    { username: DeleteUserPathParams9['username'] },
    TContext
  >
}
