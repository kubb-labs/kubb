# Implementation Example: Class-Based Client Generation

This document provides concrete code examples showing how the class-based client generation would be implemented.

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                         Plugin Entry Point                       │
│                   (plugin-client/src/plugin.ts)                  │
│                                                                   │
│  Options: { classMode: true, className: 'ApiClient', ... }      │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Generator Selection                         │
│                                                                   │
│  if (classMode) → classClientGenerator                          │
│  else → clientGenerator                                          │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Class Client Generator                        │
│            (generators/classClientGenerator.tsx)                 │
│                                                                   │
│  - Groups operations by tag (if group option set)               │
│  - Creates one class per group or one for all operations        │
│  - Passes operations to ClassClient component                   │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      ClassClient Component                       │
│              (components/ClassClient.tsx)                        │
│                                                                   │
│  - Generates class structure                                    │
│  - Creates constructor with config parameter                    │
│  - Generates method for each operation                          │
│  - Uses existing Client component logic for method bodies       │
└─────────────────────────────────────────────────────────────────┘
```

## Generated Code Examples

### Example 1: Simple Class (No Grouping)

**Configuration:**
```typescript
// kubb.config.ts
export default defineConfig({
  plugins: [
    pluginClient({
      output: { path: './clients' },
      classMode: true,
      className: 'PetStoreClient',
      client: 'axios',
    }),
  ],
})
```

**Generated Output:**
```typescript
// clients/PetStoreClient.ts
import { fetch } from '@kubb/plugin-client/clients/axios'
import type { RequestConfig, ResponseErrorConfig } from '@kubb/plugin-client/clients/axios'
import type {
  GetPetByIdQueryResponse,
  GetPetByIdPathParams,
  GetPetById400,
  GetPetById404,
  AddPetMutationRequest,
  AddPetMutationResponse,
  AddPet405,
  UpdatePetMutationRequest,
  UpdatePetMutationResponse,
  UpdatePet400,
  UpdatePet404,
  UpdatePet405,
} from './models'

/**
 * PetStore API Client
 * Generated by Kubb
 */
export class PetStoreClient {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }

  /**
   * @description Returns a single pet
   * @summary Find pet by ID
   * {@link /pet/:petId}
   */
  async getPetById(
    petId: GetPetByIdPathParams['petId'],
    config: Partial<RequestConfig> = {}
  ): Promise<GetPetByIdQueryResponse> {
    const mergedConfig = this.mergeConfig(config)
    
    const res = await this.client<
      GetPetByIdQueryResponse,
      ResponseErrorConfig<GetPetById400 | GetPetById404>,
      unknown
    >({
      method: 'GET',
      url: `/pet/${petId}`,
      ...mergedConfig,
    })
    
    return res.data
  }

  /**
   * @description Add a new pet to the store
   * @summary Add a new pet
   * {@link /pet}
   */
  async addPet(
    data: AddPetMutationRequest,
    config: Partial<RequestConfig> = {}
  ): Promise<AddPetMutationResponse> {
    const mergedConfig = this.mergeConfig(config)
    const requestData = data
    
    const res = await this.client<
      AddPetMutationResponse,
      ResponseErrorConfig<AddPet405>,
      AddPetMutationRequest
    >({
      method: 'POST',
      url: '/pet',
      data: requestData,
      ...mergedConfig,
    })
    
    return res.data
  }

  /**
   * @description Update an existing pet
   * @summary Update an existing pet
   * {@link /pet}
   */
  async updatePet(
    data: UpdatePetMutationRequest,
    config: Partial<RequestConfig> = {}
  ): Promise<UpdatePetMutationResponse> {
    const mergedConfig = this.mergeConfig(config)
    const requestData = data
    
    const res = await this.client<
      UpdatePetMutationResponse,
      ResponseErrorConfig<UpdatePet400 | UpdatePet404 | UpdatePet405>,
      UpdatePetMutationRequest
    >({
      method: 'PUT',
      url: '/pet',
      data: requestData,
      ...mergedConfig,
    })
    
    return res.data
  }

  /**
   * Merge base config with method-specific config
   * @private
   */
  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}
```

### Example 2: Grouped Classes (By Tag)

**Configuration:**
```typescript
// kubb.config.ts
export default defineConfig({
  plugins: [
    pluginClient({
      output: { path: './clients' },
      classMode: true,
      group: {
        type: 'tag',
        name: ({ group }) => `${group}Client`,
      },
      client: 'fetch',
    }),
  ],
})
```

**Generated Output:**
```typescript
// clients/PetClient.ts
import { fetch } from '@kubb/plugin-client/clients/fetch'
import type { RequestConfig, ResponseErrorConfig } from '@kubb/plugin-client/clients/fetch'
import type {
  GetPetByIdQueryResponse,
  GetPetByIdPathParams,
  AddPetMutationRequest,
  AddPetMutationResponse,
  // ... other pet-related types
} from './models'

export class PetClient {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }

  async getPetById(
    petId: GetPetByIdPathParams['petId'],
    config: Partial<RequestConfig> = {}
  ): Promise<GetPetByIdQueryResponse> {
    // ... implementation
  }

  async addPet(
    data: AddPetMutationRequest,
    config: Partial<RequestConfig> = {}
  ): Promise<AddPetMutationResponse> {
    // ... implementation
  }

  // ... other pet operations

  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}
```

```typescript
// clients/UserClient.ts
import { fetch } from '@kubb/plugin-client/clients/fetch'
import type { RequestConfig, ResponseErrorConfig } from '@kubb/plugin-client/clients/fetch'
import type {
  GetUserByNameQueryResponse,
  GetUserByNamePathParams,
  CreateUserMutationRequest,
  // ... other user-related types
} from './models'

export class UserClient {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }

  async getUserByName(
    username: GetUserByNamePathParams['username'],
    config: Partial<RequestConfig> = {}
  ): Promise<GetUserByNameQueryResponse> {
    // ... implementation
  }

  async createUser(
    data: CreateUserMutationRequest,
    config: Partial<RequestConfig> = {}
  ): Promise<void> {
    // ... implementation
  }

  // ... other user operations

  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}
```

### Example 3: With Zod Parser

**Configuration:**
```typescript
// kubb.config.ts
export default defineConfig({
  plugins: [
    pluginZod(),
    pluginClient({
      output: { path: './clients' },
      classMode: true,
      parser: 'zod',
      client: 'axios',
    }),
  ],
})
```

**Generated Output:**
```typescript
// clients/ApiClient.ts
import { fetch } from '@kubb/plugin-client/clients/axios'
import type { RequestConfig, ResponseErrorConfig } from '@kubb/plugin-client/clients/axios'
import {
  GetPetByIdQueryResponseSchema,
  AddPetMutationRequestSchema,
  AddPetMutationResponseSchema,
} from './zod'
import type {
  GetPetByIdQueryResponse,
  GetPetByIdPathParams,
  AddPetMutationRequest,
  AddPetMutationResponse,
} from './models'

export class ApiClient {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }

  async getPetById(
    petId: GetPetByIdPathParams['petId'],
    config: Partial<RequestConfig> = {}
  ): Promise<GetPetByIdQueryResponse> {
    const mergedConfig = this.mergeConfig(config)
    
    const res = await this.client<GetPetByIdQueryResponse, ResponseErrorConfig, unknown>({
      method: 'GET',
      url: `/pet/${petId}`,
      ...mergedConfig,
    })
    
    // Parse response with Zod
    return GetPetByIdQueryResponseSchema.parse(res.data)
  }

  async addPet(
    data: AddPetMutationRequest,
    config: Partial<RequestConfig> = {}
  ): Promise<AddPetMutationResponse> {
    const mergedConfig = this.mergeConfig(config)
    
    // Parse request with Zod
    const requestData = AddPetMutationRequestSchema.parse(data)
    
    const res = await this.client<AddPetMutationResponse, ResponseErrorConfig, AddPetMutationRequest>({
      method: 'POST',
      url: '/pet',
      data: requestData,
      ...mergedConfig,
    })
    
    // Parse response with Zod
    return AddPetMutationResponseSchema.parse(res.data)
  }

  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}
```

### Example 4: With Object Params Type

**Configuration:**
```typescript
// kubb.config.ts
export default defineConfig({
  plugins: [
    pluginClient({
      output: { path: './clients' },
      classMode: true,
      paramsType: 'object',
      pathParamsType: 'object',
    }),
  ],
})
```

**Generated Output:**
```typescript
export class ApiClient {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }

  async getPetById(
    { petId }: { petId: GetPetByIdPathParams['petId'] },
    config: Partial<RequestConfig> = {}
  ): Promise<GetPetByIdQueryResponse> {
    const mergedConfig = this.mergeConfig(config)
    
    const res = await this.client<GetPetByIdQueryResponse, ResponseErrorConfig, unknown>({
      method: 'GET',
      url: `/pet/${petId}`,
      ...mergedConfig,
    })
    
    return res.data
  }

  async findPetsByStatus(
    {
      params,
    }: {
      params: FindPetsByStatusQueryParams
    },
    config: Partial<RequestConfig> = {}
  ): Promise<FindPetsByStatusQueryResponse> {
    const mergedConfig = this.mergeConfig(config)
    
    const res = await this.client<FindPetsByStatusQueryResponse, ResponseErrorConfig, unknown>({
      method: 'GET',
      url: '/pet/findByStatus',
      params,
      ...mergedConfig,
    })
    
    return res.data
  }

  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}
```

## Usage Examples

### Basic Usage

```typescript
import { PetStoreClient } from './gen/clients'

// Create client instance with custom configuration
const client = new PetStoreClient({
  baseURL: 'https://api.petstore.com',
  headers: {
    'Authorization': 'Bearer token123',
  },
})

// Use the client - no need to pass config every time
const pet = await client.getPetById('123')
console.log(pet.name) // Type-safe!

const newPet = await client.addPet({
  name: 'Fluffy',
  status: 'available',
})
```

### Multi-Tenant Usage (Original Use Case)

```typescript
import { PetStoreClient } from './gen/clients'
import { createAxiosInstance } from './auth'

// Queue-based mass integrations
async function processIntegration(tenantId: string, tasks: Task[]) {
  // Create a client instance per tenant
  const axiosInstance = createAxiosInstance({
    tenantId,
    apiKey: await getTenantApiKey(tenantId),
  })
  
  const client = new PetStoreClient({
    client: axiosInstance,
    baseURL: `https://${tenantId}.api.example.com`,
  })
  
  // Process all tasks with the same client
  for (const task of tasks) {
    switch (task.type) {
      case 'CREATE_PET':
        await client.addPet(task.data)
        break
      case 'UPDATE_PET':
        await client.updatePet(task.data)
        break
      case 'GET_PET':
        const pet = await client.getPetById(task.petId)
        await processPet(pet)
        break
    }
  }
  
  // No need to pass config to every call!
  // No risk of forgetting the config!
}
```

### Override Config Per Call

```typescript
const client = new PetStoreClient({
  baseURL: 'https://api.petstore.com',
})

// Use default config
const pet1 = await client.getPetById('123')

// Override config for specific call
const pet2 = await client.getPetById('456', {
  signal: AbortSignal.timeout(5000), // Custom timeout
  headers: {
    'X-Custom-Header': 'value',
  },
})
```

### Grouped Clients

```typescript
import { PetClient, UserClient, StoreClient } from './gen/clients'

// Create separate client instances for different services
const petClient = new PetClient({ baseURL: 'https://api.petstore.com' })
const userClient = new UserClient({ baseURL: 'https://api.petstore.com' })
const storeClient = new StoreClient({ baseURL: 'https://api.petstore.com' })

// Use them independently
const pet = await petClient.getPetById('123')
const user = await userClient.getUserByName('john')
const order = await storeClient.getOrderById('789')
```

### With Dependency Injection

```typescript
class PetService {
  constructor(private client: PetStoreClient) {}
  
  async findAvailablePets() {
    return this.client.findPetsByStatus({ status: 'available' })
  }
  
  async adoptPet(petId: string, userId: string) {
    const pet = await this.client.getPetById(petId)
    await this.client.updatePet({
      ...pet,
      status: 'sold',
      ownerId: userId,
    })
  }
}

// Easy to test with mocks
const mockClient = new PetStoreClient({ client: mockFetch })
const service = new PetService(mockClient)
```

## Implementation Code Snippets

### ClassClient Component (Simplified)

```typescript
// packages/plugin-client/src/components/ClassClient.tsx
import { File, Function } from '@kubb/react-fabric'
import type { Operation } from '@kubb/oas'
import type { PluginClient } from '../types'

type Props = {
  name: string
  operations: Array<Operation>
  options: PluginClient['resolvedOptions']
}

export function ClassClient({ name, operations, options }: Props): KubbNode {
  return (
    <File.Source name={name} isExportable isIndexable>
      {`export class ${name} {
  private client: typeof fetch
  private baseConfig: Partial<RequestConfig>

  constructor(config: Partial<RequestConfig> = {}) {
    this.client = config.client || fetch
    this.baseConfig = config
  }
`}
      
      {operations.map((operation) => (
        <ClassMethod
          key={operation.getOperationId()}
          operation={operation}
          options={options}
        />
      ))}

      {`
  private mergeConfig(config: Partial<RequestConfig>): Partial<RequestConfig> {
    return {
      ...this.baseConfig,
      ...config,
      headers: {
        ...this.baseConfig.headers,
        ...config.headers,
      },
    }
  }
}`}
      
      {'\n}'}
    </File.Source>
  )
}
```

### ClassMethod Component (Simplified)

```typescript
// packages/plugin-client/src/components/ClassMethod.tsx
import { Function } from '@kubb/react-fabric'
import { Client } from './Client'

type Props = {
  operation: Operation
  options: PluginClient['resolvedOptions']
}

export function ClassMethod({ operation, options }: Props): KubbNode {
  const { getSchemas, getName } = useOperationManager()
  
  const name = getName(operation, { type: 'function' })
  const typeSchemas = getSchemas(operation, { pluginKey: [pluginTsName], type: 'type' })
  
  // Reuse existing Client component logic but adapt for class method
  return (
    <Function
      name={name}
      async
      params={Client.getParams({
        paramsType: options.paramsType,
        paramsCasing: options.paramsCasing,
        pathParamsType: options.pathParamsType,
        typeSchemas,
        isConfigurable: true,
      }).toConstructor()}
      returnType={typeSchemas.response.name}
      JSDoc={{
        comments: getComments(operation),
      }}
    >
      const mergedConfig = this.mergeConfig(config)
      <br />
      {/* Reuse Client component body logic */}
      <Client
        name={name}
        operation={operation}
        typeSchemas={typeSchemas}
        options={options}
        isConfigurable={false} // We handle config in the class
      >
        {/* Custom return logic for class methods */}
      </Client>
    </Function>
  )
}
```

## Benefits Summary

✅ **Solves the original problem**: No need to pass client config to every call
✅ **Type-safe**: Full TypeScript support with proper types
✅ **Flexible**: Can override config per-call when needed
✅ **Backward compatible**: Existing function-based code continues to work
✅ **Multi-tenant friendly**: Easy to create multiple client instances
✅ **Testable**: Easy to mock and inject dependencies
✅ **Familiar pattern**: Standard OOP class pattern
✅ **Maintains all features**: Works with zod parser, grouping, different param types, etc.

## Comparison: Before vs After

### Before (Current Function-Based)

```typescript
// Every call needs the config
const pet1 = await getPetById('123', { client: customClient })
const pet2 = await addPet(data, { client: customClient })
const pet3 = await updatePet(data, { client: customClient })

// Easy to forget!
const pet4 = await getPetById('456') // ❌ Uses default client
```

### After (Class-Based)

```typescript
// Configure once
const client = new PetStoreClient({ client: customClient })

// Use everywhere
const pet1 = await client.getPetById('123')
const pet2 = await client.addPet(data)
const pet3 = await client.updatePet(data)
const pet4 = await client.getPetById('456') // ✅ Uses custom client
```

## Conclusion

The class-based client generation provides a clean, type-safe, and ergonomic solution to the problem of managing client configuration across multiple API calls. It maintains backward compatibility while offering a more intuitive API for users working with multi-tenant systems or queue-based integrations.
