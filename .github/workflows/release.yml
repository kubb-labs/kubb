name: ðŸš€ Release
on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional: Custom tag for canary release'
        required: false
        type: string
  push:
    branches: ["main", "alpha", "beta", "rc"]
    paths:
      - ".changeset/**"
      - "packages/**"
permissions:
  actions: write
  contents: write
  id-token: write
  packages: write
  pull-requests: write
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  release:
    name: ðŸ“¦ Release
    timeout-minutes: 15
    runs-on: ubuntu-latest
    outputs:
      published_packages: ${{ steps.changesets.outputs.publishedPackages }}
      published: ${{ steps.changesets.outputs.published }}
    steps:
      - name: â¬‡ï¸ Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ”§ Setup
        uses: ./.github/setup

      - name: ðŸ—ï¸ Build
        run: pnpm run build

      - name: ðŸ§ª Test
        run: pnpm run test

      - name: ðŸ“Š Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: ðŸ“¢ Publish
        id: changesets
        uses: changesets/action@v1
        if: ${{ github.event.inputs.tag == '' }}
        with:
          publish: pnpm release
          commit: "ci(changesets): version packages"
          setupGitUser: false
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ¤ Publish ${{ inputs.tag || 'canary' }}
        id: canary
        if: steps.changesets.outputs.published != 'true'
        run: |
          git checkout main
          pnpm version:canary
          pnpm release:canary --tag ${{ inputs.tag || 'canary' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_CONFIG_PROVENANCE: true

  notify:
    name: ðŸ’¬ Send Discord Notification
    if: needs.release.outputs.published == 'true'
    needs: [release]
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ”” Send a discord notification
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          PUBLISHED_PACKAGES: ${{ needs.release.outputs.published_packages }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const publishedPackages = JSON.parse(process.env.PUBLISHED_PACKAGES || '[]');
            const corePackage = publishedPackages.find(pkg => pkg.name === '@kubb/core');
            const version = corePackage?.version || '';
            const versionSlug = version.replace(/\./g, '-');
            const docsUrl = version ? `https://www.kubb.dev/changelog#_${versionSlug}` : 'https://www.kubb.dev/changelog';
            
            fetch(process.env.DISCORD_WEBHOOK_URL, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                content: `A new release is available ðŸŽ‰. \n [Read the changelog](https://github.com/kubb-labs/kubb/releases) \n [View docs changelog](${docsUrl})`
              }),
            })
            .then((res) => {
              console.log('Sent discord notification', res)
            })
            .catch((err) => {
              console.error('Error sending discord notification', err)
            })

  comment:
    name: ðŸ’¬ Comment on related issues and pull requests
    if: needs.release.outputs.published == 'true'
    needs: [release]
    runs-on: ubuntu-latest
    permissions:
      issues: write # enable commenting on released issues
      pull-requests: write # enable commenting on released pull requests
    steps:
      - name: â¬‡ï¸ Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # IMPORTANT: if you make changes here, also make them in release-comment-manual.yml
      - name: ðŸ’¬ Comment on related issues and pull requests
        uses: remix-run/release-comment-action@v0.5.1
        with:
          DIRECTORY_TO_CHECK: "./packages"
          PACKAGE_NAME: "@kubb/core"
          ISSUE_LABELS_TO_KEEP_OPEN: "ðŸ—º Roadmap"

      - name: ðŸ“š Add docs changelog link to comments
        uses: actions/github-script@v7
        env:
          PUBLISHED_PACKAGES: ${{ needs.release.outputs.published_packages }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const publishedPackages = JSON.parse(process.env.PUBLISHED_PACKAGES || '[]');
            const corePackage = publishedPackages.find(pkg => pkg.name === '@kubb/core');
            if (!corePackage) {
              console.log('No @kubb/core package found in published packages');
              return;
            }
            
            const version = corePackage.version;
            const versionSlug = version.replace(/\./g, '-');
            const docsUrl = `https://www.kubb.dev/changelog#_${versionSlug}`;
            const docsComment = `ðŸ“š View the detailed changelog: ${docsUrl}`;
            
            console.log(`Version: ${version}, Docs URL: ${docsUrl}`);
            
            // Get the latest tag for this version
            const tagName = `@kubb/core@${version}`;
            
            // Find the previous tag to determine the commit range
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 10
            });
            
            const currentTagIndex = tags.findIndex(tag => tag.name === tagName);
            if (currentTagIndex === -1) {
              console.log(`Tag ${tagName} not found`);
              return;
            }
            
            const currentTag = tags[currentTagIndex];
            const previousTag = tags[currentTagIndex + 1];
            
            if (!previousTag) {
              console.log('No previous tag found');
              return;
            }
            
            console.log(`Comparing ${previousTag.name} to ${currentTag.name}`);
            
            // Get commits between tags
            const { data: comparison } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: previousTag.commit.sha,
              head: currentTag.commit.sha
            });
            
            // Find PRs for each commit
            const prNumbers = new Set();
            for (const commit of comparison.commits) {
              try {
                const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: commit.sha
                });
                
                for (const pr of prs) {
                  if (pr.merged_at) {
                    prNumbers.add(pr.number);
                  }
                }
              } catch (error) {
                console.log(`Error finding PRs for commit ${commit.sha}: ${error.message}`);
              }
            }
            
            console.log(`Found ${prNumbers.size} PRs`);
            
            // Comment on each PR and its linked issues
            for (const prNumber of prNumbers) {
              try {
                // Comment on PR
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: docsComment
                });
                console.log(`Commented on PR #${prNumber}`);
                
                // Get linked issues from PR
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                
                // Extract issue numbers from PR body
                const issueRegex = /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)(?::)?\s+#(\d+)/gi;
                const matches = [...(pr.body || '').matchAll(issueRegex)];
                
                for (const match of matches) {
                  const issueNumber = parseInt(match[1], 10);
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: docsComment
                    });
                    console.log(`Commented on issue #${issueNumber}`);
                  } catch (error) {
                    console.log(`Error commenting on issue #${issueNumber}: ${error.message}`);
                  }
                }
              } catch (error) {
                console.log(`Error processing PR #${prNumber}: ${error.message}`);
              }
            }
