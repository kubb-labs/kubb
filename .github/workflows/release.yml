# We use this singular file for all of our releases because we can only specify
# a singular GitHub workflow file in npm's Trusted Publishing configuration.
# See https://docs.npmjs.com/trusted-publishers for more info.
#
# Specific jobs only run on the proper trigger:
#
# - Changesets-driven pre-releases/stable releases
#   - Trigger: push to main/alpha/beta/rc branch
#   - jobs: release -> find_package_version -> comment
# - Nightly releases
#   - Trigger: schedule/cron
#   - jobs: release-nightly
# - Experimental releases (from a workflow_dispatch trigger)
#   - Trigger: workflow_dispatch
#   - jobs: release-experimental

name: üö¢ Release
on:
  # Changesets-driven prereleases and stable releases
  push:
    branches: ["main", "alpha", "beta", "rc"]
    paths:
      - ".changeset/**"
      - "packages/**"
  # Nightly releases
  schedule:
    - cron: "0 7 * * *" # every day at 7AM UTC
  # Experimental Releases
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to create experimental release from'
        required: true
        type: string
      tag:
        description: 'Optional: Custom tag for canary release (only used if branch is main)'
        required: false
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CI: true

jobs:
  release:
    name: ü¶ã Changesets Release
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      published_packages: ${{ steps.changesets.outputs.publishedPackages }}
      published: ${{ steps.changesets.outputs.published }}
    permissions:
      contents: write # enable pushing changes to the origin
      id-token: write # enable generation of an ID token for publishing
      pull-requests: write # enable opening a PR for the release
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Setup
        uses: ./.github/setup

      - name: üèó Build
        run: pnpm run build

      - name: üß™ Test
        run: pnpm run test

      - name: üìä Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

        # This action has two responsibilities. The first time the workflow runs
        # (initial push to a branch) it will create a new branch and
        # then open a PR with the related changes for the new version. After the
        # PR is merged, the workflow will run again and this action will build +
        # publish to npm.
      - name: üöÄ PR / Publish
        id: changesets
        uses: changesets/action@v1
        with:
          version: pnpm run version
          commit: "chore: Update version for release"
          title: "chore: Update version for release"
          publish: pnpm run release
          createGithubReleases: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true

  find_package_version:
    name: ü¶ã Find Package Version
    needs: [release]
    runs-on: ubuntu-latest
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'push' && needs.release.outputs.published == 'true'
    outputs:
      package_version: ${{ steps.find_package_version.outputs.package_version }}
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4

      - name: üì¶ Setup
        uses: ./.github/setup

      - id: find_package_version
        run: |
          package_version=$(node ./scripts/find-release-from-changeset.js)
          echo "package_version=${package_version}" >> "$GITHUB_OUTPUT"
        env:
          PACKAGE_VERSION_TO_FOLLOW: "@kubb/core"
          PUBLISHED_PACKAGES: ${{ needs.release.outputs.published_packages }}

  comment:
    name: üìù Comment on related issues and pull requests
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'push' && needs.find_package_version.outputs.package_version != ''
    needs: [release, find_package_version]
    runs-on: ubuntu-latest
    permissions:
      issues: write # enable commenting on released issues
      pull-requests: write # enable commenting on released pull requests
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìù Trigger issue comment workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const releaseTag = 'kubb@${{ needs.find_package_version.outputs.package_version }}';
            
            console.log(`Triggering issue comment workflow for release: ${releaseTag}`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'issue-comment-on-release.yml',
                ref: 'main',
                inputs: {
                  release_tag: releaseTag,
                  dry_run: 'false'
                }
              });
              console.log(`Successfully triggered issue comment workflow for ${releaseTag}`);
            } catch (error) {
              console.error(`Failed to trigger workflow: ${error.message}`);
              // Don't fail the release if commenting fails
            }

  discord_notification:
    name: üí¨ Send Discord Notification
    needs: [release]
    runs-on: ubuntu-latest
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'push' && needs.release.outputs.published == 'true'
    steps:
      - name: üì¢ Send a discord notification
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            fetch(process.env.DISCORD_WEBHOOK_URL, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                content: `A new release is available üéâ. \n [Read the changelog](https://github.com/kubb-labs/kubb/releases)`
              }),
            })
            .then((res) => {
              console.log('Sent discord notification', res)
            })
            .catch((err) => {
              console.error('Error sending discord notification', err)
            })

  # HEADS UP! this "nightly" job will only ever run on the `main` branch due to
  # it being a cron job, and the last commit on main will be what github shows
  # as the trigger however in the checkout below we specify the `main` branch,
  # so all the scripts in this job will be ran from that, confusing i know
  release-nightly:
    name: üåí Nightly Release
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'schedule'
    runs-on: ubuntu-latest
    permissions:
      contents: write # enable pushing changes to the origin
      id-token: write # enable generation of an ID token for publishing
    outputs:
      # will be undefined if there's no release necessary
      NEXT_VERSION: ${{ steps.version.outputs.NEXT_VERSION }}
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          ref: main
          # checkout using a custom token so that we can push later on
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üì¶ Setup
        uses: ./.github/setup

      - name: üïµÔ∏è Check for changes
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)

          # get latest nightly tag
          LATEST_NIGHTLY_TAG=$(git tag -l v0.0.0-nightly-\* --sort=-creatordate | head -n 1)

          # check if last commit to main starts with the nightly tag we're about
          # to create (minus the date)
          # if it is, we'll skip the nightly creation
          # if not, we'll create a new nightly tag
          if [[ ${LATEST_NIGHTLY_TAG} == v0.0.0-nightly-${SHORT_SHA}-* ]]; then
            echo "üõë Latest nightly tag is the same as the latest commit sha, skipping nightly release"
          else
            # yyyyMMdd format (e.g. 20221207)
            DATE=$(date '+%Y%m%d')
            # v0.0.0-nightly-<short sha>-<date>
            NEXT_VERSION=0.0.0-nightly-${SHORT_SHA}-${DATE}
            # set output so it can be used in other jobs
            echo "NEXT_VERSION=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          fi

      - name: ‚§¥Ô∏è Update version
        if: steps.version.outputs.NEXT_VERSION
        run: |
          git config --local user.email "hello@kubb.dev"
          git config --local user.name "Kubb Bot"
          git checkout -b nightly/${{ steps.version.outputs.NEXT_VERSION }}
          pnpm run version "${{ steps.version.outputs.NEXT_VERSION }}"
          git push origin --tags

      - name: üèó Build
        if: steps.version.outputs.NEXT_VERSION
        run: pnpm run build

      - name: üöÄ Publish
        if: steps.version.outputs.NEXT_VERSION
        run: pnpm run release
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true

  release-experimental:
    name: üß™ Experimental Release
    if: github.repository == 'kubb-labs/kubb' && github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write # enable pushing changes to the origin
      id-token: write # enable generation of an ID token for publishing
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
          # checkout using a custom token so that we can push later on
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üì¶ Setup
        uses: ./.github/setup

      - name: üèó Build
        run: pnpm run build

      - name: ‚§¥Ô∏è Update version and publish
        run: |
          git config --local user.email "hello@kubb.dev"
          git config --local user.name "Kubb Bot"
          SHORT_SHA=$(git rev-parse --short HEAD)
          
          # Check if we're on main branch and have a custom tag
          if [ "${{ github.event.inputs.branch }}" == "main" ] && [ "${{ github.event.inputs.tag }}" != "" ]; then
            # Use canary versioning for main branch with custom tag
            git checkout main
            pnpm run version:canary
            pnpm run release:canary --tag "${{ github.event.inputs.tag }}"
          else
            # Use experimental versioning for other branches
            NEXT_VERSION="0.0.0-experimental-${SHORT_SHA}"
            git checkout -b "experimental/${NEXT_VERSION}"
            pnpm run version "${NEXT_VERSION}"
            git push origin --tags
            pnpm run release
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true
