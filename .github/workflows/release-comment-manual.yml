# Used to manually trigger the release comments workflow

name: ðŸ’¬ Release Comment (Manual)
on:
  workflow_dispatch:
    inputs:
      dryRun:
        description: "Should this be a dry run? (true/false)"
        type: "boolean"
        required: true

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CI: true

jobs:
  comment:
    name: ðŸ’¬ Comment on related issues and pull requests
    runs-on: ubuntu-latest
    permissions:
      issues: write # enable commenting on released issues
      pull-requests: write # enable commenting on released pull requests
    steps:
      - name: â¬‡ï¸ Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ·ï¸ Fetch tags
        run: git fetch --tags

      # IMPORTANT: if you make changes here, also make them in release.yml
      - name: ðŸ’¬ Comment on related issues and pull requests
        uses: remix-run/release-comment-action@v0.5.1
        with:
          DRY_RUN: ${{ github.event.inputs.dryRun }}
          DIRECTORY_TO_CHECK: "./packages"
          PACKAGE_NAME: "@kubb/core"
          ISSUE_LABELS_TO_KEEP_OPEN: "ðŸ—º Roadmap"

      - name: ðŸ“š Add docs changelog link to comments
        if: ${{ github.event.inputs.dryRun != 'true' }}
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get all tags and select the latest @kubb/core tag by semantic version
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100 // Increase to ensure we get all relevant tags
            });
            
            // Filter tags for @kubb/core@, sort by version descending, and select the latest
            // This ensures we always get the latest version, regardless of API ordering
            const semverCompare = (a, b) => {
              const parse = v => {
                // Extract just the numeric version parts, ignore pre-release/metadata
                const match = v.match(/^(\d+)\.(\d+)\.(\d+)/);
                if (!match) return [0, 0, 0];
                return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
              };
              const [a1, a2, a3] = parse(a);
              const [b1, b2, b3] = parse(b);
              if (a1 !== b1) return b1 - a1;
              if (a2 !== b2) return b2 - a2;
              return b3 - a3;
            };
            const coreTags = tags
              .filter(tag => tag.name.startsWith('@kubb/core@'))
              .sort((a, b) => semverCompare(
                a.name.replace('@kubb/core@', ''),
                b.name.replace('@kubb/core@', '')
              ));
            const coreTag = coreTags[0];
            if (!coreTag) {
              console.log('No @kubb/core tag found');
              return;
            }
            
            const version = coreTag.name.replace('@kubb/core@', '');
            if (!version) {
              console.log('Invalid version extracted from tag');
              return;
            }
            
            const versionSlug = version.replace(/\./g, '-');
            const docsUrl = `https://www.kubb.dev/changelog#_${versionSlug}`;
            const docsComment = `ðŸ“š View the detailed changelog: ${docsUrl}`;
            
            console.log(`Version: ${version}, Docs URL: ${docsUrl}`);
            
            // Find the previous tag to determine the commit range
            const currentTagIndex = tags.findIndex(tag => tag.name === coreTag.name);
            const previousTag = tags[currentTagIndex + 1];
            
            if (!previousTag) {
              console.log('No previous tag found');
              return;
            }
            
            console.log(`Comparing ${previousTag.name} to ${coreTag.name}`);
            
            // Get commits between tags
            const { data: comparison } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: previousTag.commit.sha,
              head: coreTag.commit.sha
            });
            
            // Concurrency limiter (like p-limit)
            function pLimit(concurrency) {
              let activeCount = 0
              const queue = []
              const next = () => {
                if (queue.length === 0 || activeCount >= concurrency) return
                activeCount++
                const { fn, resolve, reject } = queue.shift()
                fn().then(resolve, reject).finally(() => {
                  activeCount--
                  next()
                })
              }
              return (fn) => new Promise((resolve, reject) => {
                queue.push({ fn, resolve, reject })
                setTimeout(() => next(), 0)
              })
            }
            
            // Find PRs for each commit (in parallel with concurrency limit)
            const prNumbers = new Set();
            const commitLimit = pLimit(5); // Limit to 5 concurrent requests
            await Promise.all(
              comparison.commits.map(commit =>
                commitLimit(async () => {
                  try {
                    const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      commit_sha: commit.sha
                    });
                    
                    for (const pr of prs) {
                      if (pr.merged_at) {
                        prNumbers.add(pr.number);
                      }
                    }
                  } catch (error) {
                    console.log(`Error finding PRs for commit ${commit.sha}: ${error.message}`);
                  }
                })
              )
            );
            
            console.log(`Found ${prNumbers.size} PRs`);
            
            const prLimit = pLimit(3) // max 3 PRs in parallel
            const issueLimit = pLimit(3) // max 3 issues in parallel

            await Promise.all(
              Array.from(prNumbers).map(prNumber =>
                prLimit(async () => {
                  try {
                    // Comment on PR
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      body: docsComment
                    })
                    console.log(`Commented on PR #${prNumber}`)

                    // Get linked issues from PR using GraphQL
                    const prHtmlUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}`
                    const query = `
                      query($prHtmlUrl: URI!) {
                        resource(url: $prHtmlUrl) {
                          ... on PullRequest {
                            closingIssuesReferences(first: 10) {
                              nodes {
                                number
                              }
                            }
                          }
                        }
                      }
                    `
                    try {
                      const result = await github.graphql(query, { prHtmlUrl })
                      const issues = result.resource?.closingIssuesReferences?.nodes || []

                      await Promise.all(
                        issues.map(issue =>
                          issueLimit(async () => {
                            try {
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                body: docsComment
                              })
                              console.log(`Commented on issue #${issue.number}`)
                            } catch (error) {
                              console.log(`Error commenting on issue #${issue.number}: ${error.message}`)
                            }
                          })
                        )
                      )
                    } catch (error) {
                      console.log(`Error fetching linked issues for PR #${prNumber}: ${error.message}`)
                    }
                  } catch (error) {
                    console.log(`Error processing PR #${prNumber}: ${error.message}`)
                  }
                })
              )
            )
