# This workflow automatically comments on issues that have been fixed in a release.
# It is triggered when a new release is published and performs the following:
# 1. Extracts PR numbers from the release notes
# 2. For each PR, finds linked issues via keywords (fixes, closes, resolves) or timeline events
# 3. Comments on each closed issue with release details and documentation links
name: Comment on Issues Fixed in Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to test with (e.g., kubb@3.0.146)'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode (will not post comments, only log what would be posted)'
        required: false
        type: boolean
        default: true

permissions:
  issues: write
  pull-requests: read

jobs:
  comment-on-issues:
    name: Comment on Fixed Issues
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Comment on issues fixed in this release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Configuration constants
            const DOCS_URL = 'https://kubb.dev';
            const CHANGELOG_URL = `${DOCS_URL}/changelog`;
            
            // Handle both release event and manual workflow_dispatch
            let releaseTag, releaseName, releaseUrl, releaseBody;
            
            if (context.payload.release) {
              // Triggered by release event
              releaseTag = context.payload.release.tag_name;
              releaseName = context.payload.release.name || releaseTag;
              releaseUrl = context.payload.release.html_url;
              releaseBody = context.payload.release.body || '';
            } else if (context.payload.inputs?.release_tag) {
              // Triggered manually via workflow_dispatch
              releaseTag = context.payload.inputs.release_tag;
              console.log(`Manual test mode: fetching release ${releaseTag}`);
              
              try {
                const { data: release } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: releaseTag
                });
                
                releaseName = release.name || releaseTag;
                releaseUrl = release.html_url;
                releaseBody = release.body || '';
              } catch (error) {
                console.error(`Failed to fetch release: ${error.message}`);
                throw error;
              }
            } else {
              throw new Error('No release data available');
            }
            
            console.log(`Processing release: ${releaseName} (${releaseTag})`);
            
            // Extract PR numbers from the release body
            // Changesets typically format PRs as #123 or PR #123
            // We extract all # references and validate them as PRs below
            const prPattern = /#(\d+)/g;
            const potentialPRNumbers = new Set();
            let match;
            
            while ((match = prPattern.exec(releaseBody)) !== null) {
              potentialPRNumbers.add(parseInt(match[1]));
            }
            
            console.log(`Found ${potentialPRNumbers.size} potential PR references in release notes`);
            
            // For each potential PR, validate and find linked issues
            // Track multiple PRs that fix the same issue
            const issuesMap = new Map();
            
            for (const prNumber of potentialPRNumbers) {
              try {
                // Get PR details - this validates it's actually a PR
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                
                console.log(`Checking PR #${prNumber}: ${pr.title}`);
                
                // Extract issue references from PR body and title
                // Only match explicit closing keywords, not bare # references
                const issuePattern = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)/gi;
                const prText = `${pr.title} ${pr.body || ''}`;
                let issueMatch;
                
                while ((issueMatch = issuePattern.exec(prText)) !== null) {
                  const issueNumber = issueMatch[1];
                  if (issueNumber) {
                    const num = parseInt(issueNumber);
                    
                    // Track all PRs that fix this issue
                    if (!issuesMap.has(num)) {
                      issuesMap.set(num, {
                        number: num,
                        prs: [{number: prNumber, title: pr.title}]
                      });
                    } else {
                      // Add this PR to the list if not already present
                      const issue = issuesMap.get(num);
                      if (!issue.prs.some(p => p.number === prNumber)) {
                        issue.prs.push({number: prNumber, title: pr.title});
                      }
                    }
                  }
                }
                
                // Also check timeline events for linked issues
                try {
                  const { data: timelineEvents } = await github.rest.issues.listEventsForTimeline({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber
                  });
                  
                  for (const event of timelineEvents) {
                    if (event.event === 'cross-referenced' && event.source?.issue) {
                      const linkedIssue = event.source.issue;
                      if (!linkedIssue.pull_request) {
                        const num = linkedIssue.number;
                        
                        // Track all PRs that reference this issue
                        if (!issuesMap.has(num)) {
                          issuesMap.set(num, {
                            number: num,
                            prs: [{number: prNumber, title: pr.title}]
                          });
                        } else {
                          // Add this PR to the list if not already present
                          const issue = issuesMap.get(num);
                          if (!issue.prs.some(p => p.number === prNumber)) {
                            issue.prs.push({number: prNumber, title: pr.title});
                          }
                        }
                      }
                    }
                  }
                } catch (error) {
                  console.log(`Could not fetch timeline for PR #${prNumber}: ${error.message}`);
                }
                
              } catch (error) {
                // This is expected for non-PR numbers, skip silently
                console.log(`Skipping #${prNumber}: ${error.message}`);
              }
            }
            
            console.log(`Found ${issuesMap.size} issues to comment on`);
            
            // Check if in dry-run mode
            const isDryRun = context.payload.inputs?.dry_run === true || context.payload.inputs?.dry_run === 'true';
            if (isDryRun) {
              console.log('üß™ DRY RUN MODE - No comments will be posted');
            }
            
            // Comment on each issue
            for (const issue of issuesMap.values()) {
              try {
                // Check if issue exists and get its state
                const { data: issueData } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number
                });
                
                // Verify it's actually an issue, not a PR
                if (issueData.pull_request) {
                  console.log(`Skipping PR #${issue.number}`);
                  continue;
                }
                
                if (issueData.state === 'open') {
                  console.log(`Skipping open issue #${issue.number}`);
                  continue;
                }
                
                // Build PR references for the comment
                const prReferences = issue.prs.length === 1
                  ? `PR #${issue.prs[0].number}`
                  : `PRs ${issue.prs.map(p => `#${p.number}`).join(', ')}`;
                
                const commentBody = [
                  `üéâ This issue has been resolved in version **${releaseName}**!`,
                  '',
                  `The fix was included in ${prReferences}.`,
                  '',
                  'For more details, check out:',
                  `- üì¶ [Release Notes](${releaseUrl})`,
                  `- üìñ [Changelog](${CHANGELOG_URL})`,
                  `- üìö [Documentation](${DOCS_URL})`,
                  '',
                  'Thank you for reporting this issue!'
                ].join('\n');
                
                if (isDryRun) {
                  console.log(`üß™ [DRY RUN] Would comment on issue #${issue.number} (fixed by ${prReferences}):`);
                  console.log(commentBody);
                  console.log('---');
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: commentBody
                  });
                  console.log(`‚úÖ Commented on issue #${issue.number} (fixed by ${prReferences})`);
                }
              } catch (error) {
                const prList = issue.prs.map(p => `#${p.number}`).join(', ');
                console.log(`‚ùå Error commenting on issue #${issue.number} (from ${prList}): ${error.message}`);
              }
            }
            
            console.log('Finished processing all issues');
