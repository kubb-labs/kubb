# This workflow automatically comments on issues that have been fixed in a release.
# It is triggered when a new release is published and performs the following:
# 1. Extracts PR numbers from the release notes
# 2. For each PR, finds linked issues via keywords (fixes, closes, resolves) or timeline events
# 3. Comments on each closed issue with release details and documentation links
name: Comment on Issues Fixed in Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to test with (e.g., kubb@3.0.146)'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode (will not post comments, only log what would be posted)'
        required: false
        type: boolean
        default: true

permissions:
  issues: write
  pull-requests: read

jobs:
  comment-on-issues:
    name: Comment on Fixed Issues
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Comment on issues fixed in this release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Handle both release event and manual workflow_dispatch
            let releaseTag, releaseName, releaseUrl, releaseBody;
            
            if (context.payload.release) {
              // Triggered by release event
              releaseTag = context.payload.release.tag_name;
              releaseName = context.payload.release.name || releaseTag;
              releaseUrl = context.payload.release.html_url;
              releaseBody = context.payload.release.body || '';
            } else if (context.payload.inputs?.release_tag) {
              // Triggered manually via workflow_dispatch
              releaseTag = context.payload.inputs.release_tag;
              console.log(`Manual test mode: fetching release ${releaseTag}`);
              
              try {
                const { data: release } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: releaseTag
                });
                
                releaseName = release.name || releaseTag;
                releaseUrl = release.html_url;
                releaseBody = release.body || '';
              } catch (error) {
                console.error(`Failed to fetch release: ${error.message}`);
                throw error;
              }
            } else {
              throw new Error('No release data available');
            }
            
            console.log(`Processing release: ${releaseName} (${releaseTag})`);
            
            // Extract PR numbers from the release body
            // Changesets typically format PRs as #123 or PR #123
            const prPattern = /#(\d+)/g;
            const prNumbers = new Set();
            let match;
            
            while ((match = prPattern.exec(releaseBody)) !== null) {
              prNumbers.add(parseInt(match[1]));
            }
            
            console.log(`Found ${prNumbers.size} PRs in release notes`);
            
            // For each PR, find linked issues
            const issuesMap = new Map();
            
            for (const prNumber of prNumbers) {
              try {
                // Get PR details
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                
                console.log(`Checking PR #${prNumber}: ${pr.title}`);
                
                // Extract issue references from PR body and title
                // Common patterns: "fixes #123", "closes #456", "resolves #789", "#123"
                const issuePattern = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+#(\d+)|#(\d+)/gi;
                const prText = `${pr.title} ${pr.body || ''}`;
                let issueMatch;
                
                while ((issueMatch = issuePattern.exec(prText)) !== null) {
                  const issueNumber = issueMatch[1] || issueMatch[2];
                  if (issueNumber) {
                    const num = parseInt(issueNumber);
                    if (!issuesMap.has(num)) {
                      issuesMap.set(num, {
                        number: num,
                        prNumber: prNumber,
                        prTitle: pr.title
                      });
                    }
                  }
                }
                
                // Also check timeline events for linked issues
                try {
                  const { data: timelineEvents } = await github.rest.issues.listEventsForTimeline({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber
                  });
                  
                  for (const event of timelineEvents) {
                    if (event.event === 'cross-referenced' && event.source?.issue) {
                      const linkedIssue = event.source.issue;
                      if (!linkedIssue.pull_request) {
                        const num = linkedIssue.number;
                        if (!issuesMap.has(num)) {
                          issuesMap.set(num, {
                            number: num,
                            prNumber: prNumber,
                            prTitle: pr.title
                          });
                        }
                      }
                    }
                  }
                } catch (error) {
                  console.log(`Could not fetch timeline for PR #${prNumber}: ${error.message}`);
                }
                
              } catch (error) {
                console.log(`Error processing PR #${prNumber}: ${error.message}`);
              }
            }
            
            console.log(`Found ${issuesMap.size} issues to comment on`);
            
            // Check if in dry-run mode
            const isDryRun = context.payload.inputs?.dry_run === true || context.payload.inputs?.dry_run === 'true';
            if (isDryRun) {
              console.log('üß™ DRY RUN MODE - No comments will be posted');
            }
            
            // Comment on each issue
            const docsUrl = 'https://kubb.dev';
            const changelogUrl = `${docsUrl}/changelog`;
            
            for (const issue of issuesMap.values()) {
              try {
                // Check if issue is open
                const { data: issueData } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number
                });
                
                if (issueData.state === 'open') {
                  console.log(`Skipping open issue #${issue.number}`);
                  continue;
                }
                
                const commentBody = [
                  `üéâ This issue has been resolved in version **${releaseName}**!`,
                  '',
                  `The fix was included in PR #${issue.prNumber}.`,
                  '',
                  'For more details, check out:',
                  `- üì¶ [Release Notes](${releaseUrl})`,
                  `- üìñ [Changelog](${changelogUrl})`,
                  `- üìö [Documentation](${docsUrl})`,
                  '',
                  'Thank you for reporting this issue!'
                ].join('\n');
                
                if (isDryRun) {
                  console.log(`üß™ [DRY RUN] Would comment on issue #${issue.number}:`);
                  console.log(commentBody);
                  console.log('---');
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: commentBody
                  });
                  console.log(`‚úÖ Commented on issue #${issue.number}`);
                }
              } catch (error) {
                console.log(`‚ùå Error commenting on issue #${issue.number}: ${error.message}`);
              }
            }
            
            console.log('Finished processing all issues');
