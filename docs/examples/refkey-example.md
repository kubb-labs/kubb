# RefKey Example - Pet Store API

This example demonstrates how to use the RefKey system to automatically manage imports when generating a Pet Store API client.

## Overview

The RefKey system allows you to:
1. Create unique references for symbols (types, functions, constants)
2. Register symbols when they're defined
3. Automatically generate imports when symbols are used in other files

## Example Structure

We'll generate three files:
- `types.ts` - Type definitions
- `request.ts` - HTTP request utility
- `api.ts` - API client that uses both types and request utility

## Implementation

### Step 1: Create RefKeys

```typescript
import { createRef } from '@kubb/core/utils'

// Create refkeys for our symbols
const petTypeRef = createRef()
const requestRef = createRef()
```

### Step 2: Generate Types File

```tsx
import { registerSymbol } from '@kubb/core/utils'
import { File, Type } from '@kubb/react-fabric'

export function TypesComponent() {
  // Register the Pet type
  registerSymbol({
    name: 'Pet',
    path: './gen/types.ts',
    isTypeOnly: true, // This is a TypeScript type
    refkey: petTypeRef,
  })

  return (
    <File baseName="types.ts" path="./gen/types.ts">
      <File.Source>
        <Type export name="Pet">
          {`{
  id: number
  name: string
  status: 'available' | 'pending' | 'sold'
  category?: {
    id: number
    name: string
  }
  photoUrls: string[]
  tags?: Array<{
    id: number
    name: string
  }>
}`}
        </Type>
      </File.Source>
    </File>
  )
}
```

**Generated Output (`types.ts`):**
```typescript
export type Pet = {
  id: number
  name: string
  status: 'available' | 'pending' | 'sold'
  category?: {
    id: number
    name: string
  }
  photoUrls: string[]
  tags?: Array<{
    id: number
    name: string
  }>
}
```

### Step 3: Generate Request Utility

```tsx
import { registerSymbol } from '@kubb/core/utils'
import { File, Function } from '@kubb/react-fabric'

export function RequestComponent() {
  // Register the request function
  registerSymbol({
    name: 'request',
    path: './gen/request.ts',
    refkey: requestRef,
  })

  return (
    <File baseName="request.ts" path="./gen/request.ts">
      <File.Source>
        <Function 
          export 
          name="request" 
          generics="T"
          params={[
            { name: 'url', type: 'string' },
            { name: 'options', type: 'RequestInit', optional: true }
          ]}
          returnType="Promise<T>"
        >
          {`const response = await fetch(url, options)
  if (!response.ok) {
    throw new Error(\`HTTP error! status: \${response.status}\`)
  }
  return response.json() as Promise<T>`}
        </Function>
      </File.Source>
    </File>
  )
}
```

**Generated Output (`request.ts`):**
```typescript
export async function request<T>(
  url: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(url, options)
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }
  return response.json() as Promise<T>
}
```

### Step 4: Generate API Client (Using RefKeys)

```tsx
import { File, Function } from '@kubb/react-fabric'
import { resolveImportsForFile } from '@kubb/core/utils'

export function ApiComponent() {
  const currentPath = './gen/api.ts'
  
  // Specify which refkeys this file uses
  const refkeysUsed = new Set([petTypeRef, requestRef])
  
  // Automatically resolve imports
  const imports = resolveImportsForFile(currentPath, refkeysUsed)
  
  return (
    <File baseName="api.ts" path={currentPath}>
      {/* Automatically add imports */}
      {imports.map(imp => (
        <File.Import 
          key={imp.path}
          name={imp.name} 
          path={imp.path} 
          isTypeOnly={imp.isTypeOnly}
        />
      ))}
      
      <File.Source>
        <Function 
          export 
          name="getPetById"
          params={[{ name: 'petId', type: 'number' }]}
          returnType="Promise<Pet>"
        >
          {`return request<Pet>(\`/pet/\${petId}\`)`}
        </Function>
        
        <Function 
          export 
          name="findPetsByStatus"
          params={[{ 
            name: 'status', 
            type: "'available' | 'pending' | 'sold'" 
          }]}
          returnType="Promise<Pet[]>"
        >
          {`return request<Pet[]>(\`/pet/findByStatus?status=\${status}\`)`}
        </Function>
      </File.Source>
    </File>
  )
}
```

**Generated Output (`api.ts`):**
```typescript
// Imports automatically generated by RefKey system
import type { Pet } from './types'
import { request } from './request'

export async function getPetById(petId: number): Promise<Pet> {
  return request<Pet>(`/pet/${petId}`)
}

export async function findPetsByStatus(
  status: 'available' | 'pending' | 'sold'
): Promise<Pet[]> {
  return request<Pet[]>(`/pet/findByStatus?status=${status}`)
}
```

## Benefits Demonstrated

### Before RefKey System

You had to manually manage imports:

```tsx
<File baseName="api.ts" path="./gen/api.ts">
  {/* Manual import management - error-prone */}
  <File.Import name={['Pet']} path="./types" isTypeOnly />
  <File.Import name={['request']} path="./request" />
  
  <File.Source>
    {/* ... your code ... */}
  </File.Source>
</File>
```

**Problems:**
- Easy to forget imports
- Manual tracking of dependencies
- Breaks when files are moved
- Duplicate import management across files

### After RefKey System

```tsx
<File baseName="api.ts" path="./gen/api.ts">
  {/* Imports automatically resolved */}
  {resolveImportsForFile(currentPath, refkeysUsed).map(imp => (
    <File.Import key={imp.path} {...imp} />
  ))}
  
  <File.Source>
    {/* ... your code ... */}
  </File.Source>
</File>
```

**Benefits:**
✅ No manual import tracking
✅ Automatic dependency resolution
✅ Safe refactoring
✅ Type-safe references

## Advanced Usage

### Multiple Files Referencing Same Symbol

```tsx
// Multiple API endpoints can reference the same Pet type
const refkeysUsed = new Set([petTypeRef, requestRef])

// Each file automatically gets the correct imports
const importsForFile1 = resolveImportsForFile('./gen/pets-api.ts', refkeysUsed)
const importsForFile2 = resolveImportsForFile('./gen/store-api.ts', refkeysUsed)
```

### Conditional References

```tsx
export function ApiComponent({ includeTypes = true }) {
  const refkeysUsed = new Set([requestRef])
  
  // Conditionally add type references
  if (includeTypes) {
    refkeysUsed.add(petTypeRef)
  }
  
  const imports = resolveImportsForFile('./gen/api.ts', refkeysUsed)
  
  // Imports will only include Pet type if includeTypes is true
  return (
    <File baseName="api.ts" path="./gen/api.ts">
      {imports.map(imp => <File.Import key={imp.path} {...imp} />)}
      <File.Source>{/* ... */}</File.Source>
    </File>
  )
}
```

### Namespace Imports

```tsx
// Register a namespace import
registerSymbol({
  name: 'Utils',
  path: './utils',
  isNameSpace: true, // import * as Utils from './utils'
  refkey: utilsRef,
})

// Will generate: import * as Utils from './utils'
const imports = resolveImportsForFile('./gen/api.ts', new Set([utilsRef]))
```

## Complete Example

Here's a complete generator using the RefKey system:

```tsx
import { createRef, registerSymbol, resolveImportsForFile } from '@kubb/core/utils'
import { File, Type, Function } from '@kubb/react-fabric'

// Create refkeys
const petTypeRef = createRef()
const requestRef = createRef()

export function PetStoreGenerator() {
  // Register symbols
  registerSymbol({
    name: 'Pet',
    path: './gen/types.ts',
    isTypeOnly: true,
    refkey: petTypeRef,
  })
  
  registerSymbol({
    name: 'request',
    path: './gen/request.ts',
    refkey: requestRef,
  })

  return (
    <>
      {/* Types file */}
      <File baseName="types.ts" path="./gen/types.ts">
        <File.Source>
          <Type export name="Pet">
            {`{ id: number; name: string; status: string }`}
          </Type>
        </File.Source>
      </File>

      {/* Request utility */}
      <File baseName="request.ts" path="./gen/request.ts">
        <File.Source>
          <Function export name="request" generics="T">
            {`// implementation`}
          </Function>
        </File.Source>
      </File>

      {/* API client with auto-imports */}
      <File baseName="api.ts" path="./gen/api.ts">
        {resolveImportsForFile(
          './gen/api.ts',
          new Set([petTypeRef, requestRef])
        ).map(imp => (
          <File.Import key={imp.path} {...imp} />
        ))}
        
        <File.Source>
          <Function export name="getPetById">
            {`return request<Pet>('/pet/1')`}
          </Function>
        </File.Source>
      </File>
    </>
  )
}
```

## Next Steps

- Explore [RefKey API Reference](/knowledge-base/refkey)
- Learn about [Kubb Generators](/knowledge-base/generators)
- Check out [Best Practices](/knowledge-base/best-practices)
